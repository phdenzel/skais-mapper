{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>skais-mapper</code>","text":"<p>A framework for generating deep-learning SKA radio telescope &amp; cosmological hydrodynamical simulation data.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ul> <li>Install</li> <li>Usage</li> <li>API Reference</li> </ul> <p><code>skais-mapper</code> is a collection of tools for generating, plotting, and pre-processing hydrodynamics simulation (image) data for state-of-the-art generative AI models.</p> <p>It is fully compatible with SPH data from the AREPO simulator, in particular the IllustrisTNG suite.</p> <p>It provides utility routines to fetch isolated halos from simulations snapshots and various raytracing algorithms for 2D column density projections of these halos and its galaxies. Although the package is mostly built on python, the raytracing module also includes some C extensions for the intensive computation (building and visualizing datasets). The framework generates HDF5 files with image datasets of various galactic properties, such as dark matter, star, or gas column density distributions.</p>"},{"location":"install/","title":"Install","text":"<p>Tagged releases are available as PyPI packages. To install the latest package, run:</p> <pre><code>pip install skais-mapper\n</code></pre> <p>For the bleeding-edge package directly from a non-main git branch, use <pre><code>pip install git+https://github.com/phdenzel/skais-mapper.git@&lt;latest-branch&gt;\n</code></pre></p> <p>(and replace <code>&lt;latest-branch&gt;</code> with the actual branch name) or clone the repository and run the following command in the root directory of the repository:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"install/#requirements","title":"Requirements","text":"<p>Building from scratch thus requires <code>cython</code>, however <code>skais-mapper</code> ships with pre-compiled C files, making the minimal requirements</p> <ul> <li><code>python &gt;= 3.10</code></li> <li><code>gcc</code> (on linux) / <code>clang</code> (on macOS)</li> </ul> <p>Also see <code>pyproject.toml</code> for the relevant python packages.</p>"},{"location":"install/#uv","title":"uv","text":"<p><code>skais-mapper</code> is developed using <code>uv</code> and thus provides a <code>uv.lock</code> file which should make installing the package easier, faster, and universal. In the project, run</p> <pre><code>uv sync [--all-groups]\n</code></pre> <p>To add <code>skais-mapper</code> to your own project simply useful <pre><code>uv add skais-mapper\n</code></pre> and it will appear as a dependency in your <code>pyproject.toml</code>.</p>"},{"location":"install/#nix","title":"nix","text":"<p>If reproducibility is of utmost importance, you might want to look into <code>nix</code>. <code>skais-mapper</code> is packaged as nix package (see <code>default.nix</code>). To install it, you can add the following to your  nix-config and rebuild it</p> <pre><code>{pkgs, ...}: let\n    remote = builtins.fetchurl {\n        url = \"https://raw.githubusercontent.com/phdenzel/skais-mapper/refs/heads/main/default.nix\";\n        sha256 = \"sha256:13wqi39qy3hm4acjpyna591jdc22q0nz710qfirahjsl8w7biiys\";\n    };\n    skais-mapper = pkgs.callPackage remote {\n        src = pkgs.fetchFromGitHub {\n        owner = \"phdenzel\";\n        repo = \"skais-mapper\";\n        rev = \"main\";\n        sha256 = \"sha256:0232xx762a8x73lp0b6hal0aphxggwnh1hfgk6592hxyn5r1sz50\";\n    };\nin {\n    environment.systemPackages = with pkgs; [\n        skais-mapper\n    ];\n}\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>Here, the entire <code>skais-mapper</code> API is referenced. Use the search functionality to look for specific references.</p>"},{"location":"reference/#skais_mapper","title":"skais_mapper","text":"<p>The main module: sets global variables and registers OmegaConf resolvers.</p> <p>Modules:</p> Name Description <code>configs</code> <p>Configuration module for hydra.</p> <code>configure</code> <p>Inspect and create configuration files.</p> <code>cosmology</code> <p>Utilities for handling cosmology-dependent calculations.</p> <code>data</code> <p>Image/map data readers and (HDF5) writers.</p> <code>generate</code> <p>Generate maps from simulations.</p> <code>illustris</code> <p>All illustris utilities for loading simulation data.</p> <code>plotting</code> <p>Plotting routines for maps and images.</p> <code>raytrace</code> <p>skais_mapper.raytrace module:</p> <code>rotations</code> <p>Rotation operators for point cloud arrays.</p> <code>simobjects</code> <p>Tools for manipulating data objects from simulations.</p> <code>utils</code> <p>All utility functions can be imported from here.</p>"},{"location":"usage/","title":"Usage","text":"<p><code>skais-mapper</code> implements a few sub-commands for generating and manipulating simulation data.  Use the following to see what valid sub-commands exist:</p> <pre><code>[uv run] skais-mapper -h\n</code></pre> <p><code>skais-mapper</code> sub-commands implement the hydra configuration management framework. For more information on sub-command usage, inspect the <code>skais_mapper/configs/</code> directory, or use:</p> <pre><code>[uv run] skais-mapper [sub-command] -h\n</code></pre> <p>For instance, the command to generate 1000 images from snapshot 50 is as follows:</p> <pre><code>[uv run] skais-mapper generate +experiment=tng50-1-50-2D-0000-1000\n</code></pre>"},{"location":"reference/skais_mapper/","title":"skais_mapper","text":""},{"location":"reference/skais_mapper/#skais_mapper","title":"skais_mapper","text":"<p>The main module: sets global variables and registers OmegaConf resolvers.</p> <p>Modules:</p> Name Description <code>configs</code> <p>Configuration module for hydra.</p> <code>configure</code> <p>Inspect and create configuration files.</p> <code>cosmology</code> <p>Utilities for handling cosmology-dependent calculations.</p> <code>data</code> <p>Image/map data readers and (HDF5) writers.</p> <code>generate</code> <p>Generate maps from simulations.</p> <code>illustris</code> <p>All illustris utilities for loading simulation data.</p> <code>plotting</code> <p>Plotting routines for maps and images.</p> <code>raytrace</code> <p>skais_mapper.raytrace module:</p> <code>rotations</code> <p>Rotation operators for point cloud arrays.</p> <code>simobjects</code> <p>Tools for manipulating data objects from simulations.</p> <code>utils</code> <p>All utility functions can be imported from here.</p>"},{"location":"reference/skais_mapper/configs/","title":"skais_mapper.configs","text":""},{"location":"reference/skais_mapper/configs/#skais_mapper.configs","title":"skais_mapper.configs","text":"<p>Configuration module for hydra.</p>"},{"location":"reference/skais_mapper/configure/","title":"skais_mapper.configure","text":""},{"location":"reference/skais_mapper/configure/#skais_mapper.configure","title":"skais_mapper.configure","text":"<p>Inspect and create configuration files.</p> <p>Functions:</p> Name Description <code>create</code> <p>Main configuration creation routine.</p>"},{"location":"reference/skais_mapper/configure/#skais_mapper.configure.create","title":"create","text":"<pre><code>create(cfg: DictConfig | dict)\n</code></pre> <p>Main configuration creation routine.</p> Source code in <code>skais_mapper/configure.py</code> <pre><code>@hydra.main(config_path=\"configs\", config_name=\"config\", version_base=None)\ndef create(cfg: DictConfig | dict):\n    \"\"\"Main configuration creation routine.\"\"\"\n    log = logging.getLogger(__name__)\n    output_dir = HydraConfig.get().runtime.output_dir\n    opt = instantiate(cfg)\n    if not cfg.exclude_git_state:\n        log.info(f\"Git state: {skais_mapper.GIT_STATE}\")\n    if cfg.include_git_diff:\n        for d in skais_mapper.GIT_DIFF:\n            log.info(f\"Git diff: {compress_encode(d)}\")\n    log.info(f\"Job id: {opt.run_id}\")\n    log.info(f\"Output directory: {output_dir}\")\n    if opt.verbose:\n        print(\"Configuration:\")\n        print(OmegaConf.to_yaml(cfg))\n\n    if opt.save_configs:\n        hydra_subdir = Path(HydraConfig.get().output_subdir)\n        src_file = hydra_subdir / \"config.yaml\"\n        dst_file = Path(opt.output)\n        if dst_file.suffix not in [\".yaml\", \".yml\"]:\n            dst_file = Path(f\"./{opt.run_id}.yaml\")\n        dst_file.write_bytes(src_file.read_bytes())\n</code></pre>"},{"location":"reference/skais_mapper/cosmology/","title":"skais_mapper.cosmology","text":""},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology","title":"skais_mapper.cosmology","text":"<p>Utilities for handling cosmology-dependent calculations.</p> <p>Classes:</p> Name Description <code>CosmoModel</code> <p>Set cosmological parameter for distance calculations, mass projections, etc.</p>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel","title":"CosmoModel  <code>dataclass</code>","text":"<pre><code>CosmoModel(\n    omega_m: float = 0.279952,\n    omega_l: float = 0.72,\n    omega_k: float = 0.0,\n    z: float = 0.0,\n    c: ac.Constant = (lambda: ac.c)(),\n    h: float = 0.718,\n    u_H0: au.CompositeUnit = au.km / au.s / au.Mpc,\n)\n</code></pre> <p>Set cosmological parameter for distance calculations, mass projections, etc.</p> <p>Parameters:</p> Name Type Description Default <code>omega_m</code> <code>float</code> <p>matter energy fraction</p> <code>0.279952</code> <code>omega_l</code> <code>float</code> <p>dark energy fraction</p> <code>0.72</code> <code>omega_k</code> <code>float</code> <p>curvature fraction</p> <code>0.0</code> <code>omega_r</code> <code>float</code> <p>radiation energy fraction (will be calculated               assuming flat universe if not given)</p> required <code>h</code> <code>float</code> <p>'little' H (H0 / 100 km/s/Mpc)</p> <code>0.718</code> <code>c</code> <code>ac.Constant</code> <p>speed of light</p> <code>(lambda: ac.c)()</code> <code>z</code> <code>float</code> <p>redshift</p> <code>0.0</code> <p>Methods:</p> Name Description <code>H</code> <p>The Hubble parameter at a given scale factor <code>a</code>.</p> <code>arcsec2kpc</code> <p>Angular distance d_z from a redshift z within given cosmology.</p> <code>d_comov</code> <p>Calculate the comoving distance from scale factor (for solve_ivp).</p> <code>d_z</code> <p>Angular distance d_z from a redshift z within given cosmology.</p> <code>d_z2kpc</code> <p>Given scale-less distance d, return scaled distance c/H0 * d [kpc].</p> <p>Attributes:</p> Name Type Description <code>H0</code> <code>au.Quantity</code> <p>The Hubble constant getter.</p> <code>a</code> <code>float</code> <p>The scale parameter getter.</p> <code>omega_r</code> <code>float</code> <p>The radiation density parameter getter.</p> <code>rho_crit</code> <code>au.Quantity</code> <p>The critical density getter.</p>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.H0","title":"H0  <code>property</code> <code>writable</code>","text":"<pre><code>H0: au.Quantity\n</code></pre> <p>The Hubble constant getter.</p>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.a","title":"a  <code>property</code> <code>writable</code>","text":"<pre><code>a: float\n</code></pre> <p>The scale parameter getter.</p>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.omega_r","title":"omega_r  <code>property</code> <code>writable</code>","text":"<pre><code>omega_r: float\n</code></pre> <p>The radiation density parameter getter.</p>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.rho_crit","title":"rho_crit  <code>property</code>","text":"<pre><code>rho_crit: au.Quantity\n</code></pre> <p>The critical density getter.</p>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.H","title":"H","text":"<pre><code>H(a: float | None = None) -&gt; au.Quantity\n</code></pre> <p>The Hubble parameter at a given scale factor <code>a</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float | None</code> <p>scale factor</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>value of the Hubble parameter</p> Source code in <code>skais_mapper/cosmology.py</code> <pre><code>def H(self, a: float | None = None) -&gt; au.Quantity:\n    \"\"\"The Hubble parameter at a given scale factor `a`.\n\n    Args:\n        a: scale factor\n\n    Returns:\n        (float): value of the Hubble parameter\n    \"\"\"\n    if a is None and self.z and self.a:\n        a = self.a\n    elif a is None:\n        a = 1.0\n    return (\n        self.H0\n        * (self.omega_m / a**3 + self.omega_r / a**4 + self.omega_k / a**2 + self.omega_l)\n        ** 0.5\n    )\n</code></pre>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.arcsec2kpc","title":"arcsec2kpc  <code>staticmethod</code>","text":"<pre><code>arcsec2kpc(\n    z: float,\n    dist_z: float | None = None,\n    cosmo_model: TCosmo | None = None,\n) -&gt; au.Quantity\n</code></pre> <p>Angular distance d_z from a redshift z within given cosmology.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>redshift</p> required <code>dist_z</code> <code>float | None</code> <p>scaled comoving distance</p> <code>None</code> <code>cosmo_model</code> <code>TCosmo | None</code> <p>cosmological parameter lookup class</p> <code>None</code> Return <p>(float): kpc/arcsec scaling within given redshift and cosmology</p> Source code in <code>skais_mapper/cosmology.py</code> <pre><code>@staticmethod\ndef arcsec2kpc(\n    z: float,\n    dist_z: float | None = None,\n    cosmo_model: TCosmo | None = None,\n) -&gt; au.Quantity:\n    \"\"\"Angular distance d_z from a redshift z within given cosmology.\n\n    Args:\n        z: redshift\n        dist_z: scaled comoving distance\n        cosmo_model: cosmological parameter lookup class\n\n    Return:\n        (float): kpc/arcsec scaling within given redshift and cosmology\n    \"\"\"\n    if dist_z is None:\n        dist_z = CosmoModel.d_z(z, cosmo_model=cosmo_model, scaled=True)\n    d_kpc_arcsec = (dist_z / au.rad).to(au.kpc / au.arcsec)\n    return d_kpc_arcsec\n</code></pre>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.d_comov","title":"d_comov  <code>staticmethod</code>","text":"<pre><code>d_comov(\n    a: float, r: float, cosmo_model: TCosmo | None = None\n) -&gt; au.Quantity\n</code></pre> <p>Calculate the comoving distance from scale factor (for solve_ivp).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>scale factor</p> required <code>r</code> <code>float</code> <p>distance</p> required <code>cosmo_model</code> <code>TCosmo | None</code> <p>cosmological parameter lookup class</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>comoving radial distance (scale-free)</p> Source code in <code>skais_mapper/cosmology.py</code> <pre><code>@staticmethod\ndef d_comov(a: float, r: float, cosmo_model: TCosmo | None = None) -&gt; au.Quantity:\n    \"\"\"Calculate the comoving distance from scale factor (for solve_ivp).\n\n    Args:\n        a: scale factor\n        r: distance\n        cosmo_model: cosmological parameter lookup class\n\n    Returns:\n        (float): comoving radial distance (scale-free)\n    \"\"\"\n    if cosmo_model is None:\n        cosmo_model = CosmoModel()\n    return 1.0 / (a * a * cosmo_model.H(a))\n</code></pre>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.d_z","title":"d_z  <code>staticmethod</code>","text":"<pre><code>d_z(\n    z: float | None = None,\n    cosmo_model: TCosmo | None = None,\n    scaled: bool = False,\n) -&gt; au.Quantity\n</code></pre> <p>Angular distance d_z from a redshift z within given cosmology.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float | None</code> <p>redshift</p> <code>None</code> <code>cosmo_model</code> <code>TCosmo | None</code> <p>cosmological parameter lookup class</p> <code>None</code> <code>scaled</code> <code>bool</code> <p>return result with c/H0 in units of kpc</p> <code>False</code> Return <p>(float): apparent distance d_z</p> Source code in <code>skais_mapper/cosmology.py</code> <pre><code>@staticmethod\ndef d_z(\n    z: float | None = None,\n    cosmo_model: TCosmo | None = None,\n    scaled: bool = False,\n) -&gt; au.Quantity:\n    \"\"\"Angular distance d_z from a redshift z within given cosmology.\n\n    Args:\n        z: redshift\n        cosmo_model: cosmological parameter lookup class\n        scaled: return result with c/H0 in units of kpc\n\n    Return:\n        (float): apparent distance d_z\n    \"\"\"\n    if cosmo_model is None:\n        cosmo_model = CosmoModel()\n    comov = partial(CosmoModel.d_comov, cosmo_model=cosmo_model)\n    if z is None and cosmo_model.a:\n        a = cosmo_model.a\n    else:\n        a = 1.0 / (1.0 + z)\n    a_lim = [a, 1]\n    res = solve_ivp(comov, a_lim, [0])\n    if res[\"success\"]:\n        r = res[\"y\"][0]\n        D = a * (r[-1] - r[0])\n        if scaled:\n            return CosmoModel.d_z2kpc(D)\n        return D\n    raise ValueError(f\"No solution found for the inputs z={z}, \" f\"cosmo_model={cosmo_model}\")\n</code></pre>"},{"location":"reference/skais_mapper/cosmology/#skais_mapper.cosmology.CosmoModel.d_z2kpc","title":"d_z2kpc  <code>staticmethod</code>","text":"<pre><code>d_z2kpc(\n    distance: float | np.ndarray,\n    cosmo_model: TCosmo | None = None,\n) -&gt; au.Quantity\n</code></pre> <p>Given scale-less distance d, return scaled distance c/H0 * d [kpc].</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float | np.ndarray</code> <p>scale-less distance</p> required <code>cosmo_model</code> <code>TCosmo | None</code> <p>cosmological parameter lookup class</p> <code>None</code> Source code in <code>skais_mapper/cosmology.py</code> <pre><code>@staticmethod\ndef d_z2kpc(\n    distance: float | np.ndarray, cosmo_model: TCosmo | None = None\n) -&gt; au.Quantity:\n    \"\"\"Given scale-less distance d, return scaled distance c/H0 * d [kpc].\n\n    Args:\n        distance: scale-less distance\n        cosmo_model: cosmological parameter lookup class\n    \"\"\"\n    if cosmo_model is None:\n        cosmo_model = CosmoModel()\n    c = cosmo_model.c\n    H0 = cosmo_model.H0\n    return (distance * c / H0).to(au.kpc)\n</code></pre>"},{"location":"reference/skais_mapper/data/","title":"skais_mapper.data","text":""},{"location":"reference/skais_mapper/data/#skais_mapper.data","title":"skais_mapper.data","text":"<p>Image/map data readers and (HDF5) writers.</p> <p>Classes:</p> Name Description <code>Img2H5Buffer</code> <p>Parse images (incrementally or all at once) and write to HDF5 files.</p> <code>ImgRead</code> <p>Flexible image reader for multiple formats.</p>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer","title":"Img2H5Buffer","text":"<pre><code>Img2H5Buffer(\n    path: str | Path = None,\n    target: str | Path = None,\n    data: np.ndarray | dict = None,\n    size: int | float | str = \"1G\",\n)\n</code></pre> <p>Parse images (incrementally or all at once) and write to HDF5 files.</p> The directory structure of a dataset should be as follows <ul> <li>: /path/to/dataset/root <li>: image class as a subdirectory in the dataset <li>image file : {npy | jpg | png | etc.} <p>E.g. file paths of the following structure:   /path/to/dataset/root//image_class//423120.npy HDF5 files end up being:   /image_class/dataset</p> <p>Note: by default the entire dataset is loaded into cache</p> <p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to a data directory where the source files are located.</p> <code>None</code> <code>target</code> <code>str | Path</code> <p>Filename of the HDF5 file to be written.</p> <code>None</code> <code>data</code> <code>np.ndarray | dict</code> <p>Alternative input format to <code>path</code> for adding data arrays or dictionaries directly to the buffer queue.</p> <code>None</code> <code>size</code> <code>int | float | str</code> <p>Buffer cache size in bytes or passed as string.</p> <code>'1G'</code> <p>Methods:</p> Name Description <code>configure_rdcc</code> <p>Automatically configure HDF5 data chunking for optimal writing.</p> <code>flush</code> <p>Send all data pages from the buffer queue.</p> <code>glob_path</code> <p>Glob path recursively for files.</p> <code>inc_write</code> <p>Incrementally (append mode) write the buffer to HDF5 file.</p> <code>send</code> <p>Grab first data page from the buffer queue.</p> <code>store</code> <p>Insert data into the buffer queue.</p> <code>write</code> <p>Write all files in buffer to a new HDF5 file.</p> <p>Attributes:</p> Name Type Description <code>n_files</code> <code>int</code> <p>Number of files to be parsed.</p> <code>nbytes</code> <code>list[nbytes]</code> <p>List of the number of bytes for each buffer file.</p> <code>page</code> <code>np.ndarray | dict | None</code> <p>Buffer page ready to be written to file.</p> <code>total_nbytes</code> <code>list[nbytes]</code> <p>Total number of bytes for buffer.</p> Source code in <code>skais_mapper/data.py</code> <pre><code>def __init__(\n    self,\n    path: str | Path = None,\n    target: str | Path = None,\n    data: np.ndarray | dict = None,\n    size: int | float | str = \"1G\",\n):\n    \"\"\"Constructor.\n\n    Args:\n        path: Path to a data directory where the source files are located.\n        target: Filename of the HDF5 file to be written.\n        data: Alternative input format to `path` for adding data arrays or\n          dictionaries directly to the buffer queue.\n        size: Buffer cache size in bytes or passed as string.\n    \"\"\"\n    self.files = self.glob_path(path)\n    self.queue: list[np.ndarray | dict] = []\n    if isinstance(data, np.ndarray | dict):\n        self.queue.append(data)\n    if target is None:\n        target = self.default_target_name.format(current_time()[2:])\n    self.target = Path(target)\n    self.cache_size = nbytes(size)\n    self.index = -1\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.n_files","title":"n_files  <code>property</code>","text":"<pre><code>n_files: int\n</code></pre> <p>Number of files to be parsed.</p>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.nbytes","title":"nbytes  <code>property</code>","text":"<pre><code>nbytes: list[nbytes]\n</code></pre> <p>List of the number of bytes for each buffer file.</p>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.page","title":"page  <code>property</code>","text":"<pre><code>page: np.ndarray | dict | None\n</code></pre> <p>Buffer page ready to be written to file.</p>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.total_nbytes","title":"total_nbytes  <code>property</code>","text":"<pre><code>total_nbytes: list[nbytes]\n</code></pre> <p>Total number of bytes for buffer.</p>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.configure_rdcc","title":"configure_rdcc","text":"<pre><code>configure_rdcc(\n    cache_size: int | float | str | None = None,\n    f: int = 10,\n    verbose: bool = False,\n    **kwargs,\n) -&gt; dict\n</code></pre> <p>Automatically configure HDF5 data chunking for optimal writing.</p> <p>Parameters:</p> Name Type Description Default <code>cache_size</code> <code>int | float | str | None</code> <p>Cache of the entire buffer.</p> <code>None</code> <code>f</code> <code>int</code> <p>Factor with which to increase the number of slots.</p> <code>10</code> <code>verbose</code> <code>bool</code> <p>Print additional information to stdout.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments such as - <code>rdcc_nbytes</code>: See h5py.File or below for details. - <code>rdcc_w0</code>: See h5py.File or below for details. - <code>rdcc_nslots</code>: See h5py.File or below for details.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p><code>rdcc_nbytes</code>: sets the total size (measured in bytes) of the raw data chunk cache for each dataset. This should be set to the size of each chunk times the number of chunks that are likely to be needed in cache.</p> <code>dict</code> <p><code>rdcc_w0</code>: sets the eviction policy for chunks from the cache when more space is needed. 0 is always last used chunk, 1 the last used chunk fully read or written, and inbetween values hybrid policies.</p> <code>dict</code> <p><code>rdcc_nslots</code>: is the number of chunk slots in the cache for each dataset. In order to allow the chunks to be looked up quickly in cache, each chunk is hashed. Thus, it should be large enough to minimize the number of hash value collisions. At minimum 10, for maximum performance about 100 times larger as the number of chunks which fit in cache, ideally a prime number.</p> Source code in <code>skais_mapper/data.py</code> <pre><code>def configure_rdcc(\n    self,\n    cache_size: int | float | str | None = None,\n    f: int = 10,\n    verbose: bool = False,\n    **kwargs,\n) -&gt; dict:\n    \"\"\"Automatically configure HDF5 data chunking for optimal writing.\n\n    Args:\n        cache_size: Cache of the entire buffer.\n        f: Factor with which to increase the number of slots.\n        verbose: Print additional information to stdout.\n        **kwargs: Additional keyword arguments such as\n          - `rdcc_nbytes`: See h5py.File or below for details.\n          - `rdcc_w0`: See h5py.File or below for details.\n          - `rdcc_nslots`: See h5py.File or below for details.\n\n    Returns:\n        `rdcc_nbytes`: sets the total size (measured in bytes) of the raw data\n          chunk cache for each dataset. This should be set to the size of each\n          chunk times the number of chunks that are likely to be needed in cache.\n        `rdcc_w0`: sets the eviction policy for chunks from the cache when more\n          space is needed. 0 is always last used chunk, 1 the last used chunk fully\n          read or written, and inbetween values hybrid policies.\n        `rdcc_nslots`: is the number of chunk slots in the cache for each dataset.\n          In order to allow the chunks to be looked up quickly in cache, each chunk\n          is hashed. Thus, it should be large enough to minimize the number of hash\n          value collisions. At minimum 10, for maximum performance about 100 times\n          larger as the number of chunks which fit in cache, ideally a prime number.\n    \"\"\"\n    if cache_size is None:\n        cache_size = self.cache_size\n    else:\n        cache_size = nbytes(cache_size)\n    slots_size = max(self.nbytes) if self.nbytes else nbytes(\"2M\")\n    n_slots = int(cache_size / slots_size) if self.n_files else 100_000\n    # avoid calculating prime numbers if previous configuration looks similar\n    if (\n        hasattr(self, \"_rdcc\")\n        and self._rdcc[\"rdcc_nbytes\"] == int(cache_size)\n        and self._rdcc[\"rdcc_w0\"] == kwargs.get(\"rdcc_w0\", 1.0)\n    ):\n        return self._rdcc\n    kwargs.setdefault(\"rdcc_nbytes\", int(cache_size))\n    kwargs.setdefault(\"rdcc_w0\", 1.0)\n    kwargs.setdefault(\"rdcc_nslots\", next_prime(int(n_slots * f)))\n    if verbose:\n        sample_size = max(self.nbytes)\n        print(f\"Sample size: {sample_size}\")\n        print(f\"Slot size: {nbytes(kwargs['rdcc_nbytes'] / kwargs['rdcc_nslots'])}\")\n        print(f\"Slots: {kwargs['rdcc_nslots']}({n_slots})\")\n        print(f\"Cache size: {nbytes(kwargs['rdcc_nbytes'])}\")\n        print(f\"Eviction policy: {kwargs['rdcc_w0']}\")\n    self._rdcc = kwargs\n    return kwargs\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.flush","title":"flush","text":"<pre><code>flush() -&gt; (\n    np.ndarray | dict | list[np.ndarray | dict] | None\n)\n</code></pre> <p>Send all data pages from the buffer queue.</p> Source code in <code>skais_mapper/data.py</code> <pre><code>def flush(self) -&gt; np.ndarray | dict | list[np.ndarray | dict] | None:\n    \"\"\"Send all data pages from the buffer queue.\"\"\"\n    if self.files:\n        self.store(self.files)\n        self.files = []\n    if self.queue:\n        data = self.queue\n        self.queue = []\n        if len(data) == 1:\n            return data[0]\n        return data\n    return None\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.glob_path","title":"glob_path  <code>staticmethod</code>","text":"<pre><code>glob_path(\n    path: str | Path | list[str] | list[Path],\n    extensions: str | list[str] = None,\n) -&gt; list[Path]\n</code></pre> <p>Glob path recursively for files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | list[str] | list[Path]</code> <p>Filename, path or list, can contain wildcards <code>*</code> or <code>**</code>.</p> required <code>extensions</code> <code>str | list[str]</code> <p>File extension to look fo</p> <code>None</code> Source code in <code>skais_mapper/data.py</code> <pre><code>@staticmethod\ndef glob_path(\n    path: str | Path | list[str] | list[Path], extensions: str | list[str] = None\n) -&gt; list[Path]:\n    \"\"\"Glob path recursively for files.\n\n    Args:\n        path: Filename, path or list, can contain wildcards `*` or `**`.\n        extensions: File extension to look fo\n    \"\"\"\n    files: list[Path] = []\n    extensions = [extensions] if isinstance(extensions, str) else extensions\n    root, file_key = Img2H5Buffer._split_glob(path)\n    for p, k in zip(root, file_key):\n        if k is None:\n            files.append(Path(p))\n        else:\n            path_files = [\n                f\n                for f in Path(p).rglob(k)\n                if f.is_file() and f.suffix in Img2H5Buffer.extensions\n            ]\n            files += sorted(path_files)\n    files = [p for p in files if p.exists()]\n    return files\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.inc_write","title":"inc_write","text":"<pre><code>inc_write(\n    path: str | Path | None = None,\n    group: str = \"images\",\n    data: np.ndarray | dict | None = None,\n    expand_dim: bool = True,\n    axis: int = 0,\n    overwrite: bool | int | None = None,\n    verbose: bool = False,\n    **kwargs,\n)\n</code></pre> <p>Incrementally (append mode) write the buffer to HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>Filename of the HDF5 file and optionally the path of the HDF5 group where the dataset is saved.</p> <code>None</code> <code>group</code> <code>str</code> <p>HDF5 group where to save the dataset. If it does not exist, it is created.</p> <code>'images'</code> <code>data</code> <code>np.ndarray | dict | None</code> <p>Data to be written to the hdf5 file. If None, all files in the buffer are written to HDF5 file.</p> <code>None</code> <code>expand_dim</code> <code>bool</code> <p>Expand dimension of data array for stacking.</p> <code>True</code> <code>axis</code> <code>int</code> <p>Axis of the n-dimensional array where to append</p> <code>0</code> <code>overwrite</code> <code>bool | int | None</code> <p>If data should overwrite indices in a pre-existing HDF5 dataset, set to the index.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print additional information to stdout.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments for <code>Img2H5Buffer.configure_rdcc</code>, h5py.File<code>, and/or</code>h5py.Group.create_dataset`.</p> <code>{}</code> Source code in <code>skais_mapper/data.py</code> <pre><code>def inc_write(\n    self,\n    path: str | Path | None = None,\n    group: str = \"images\",\n    data: np.ndarray | dict | None = None,\n    expand_dim: bool = True,\n    axis: int = 0,\n    overwrite: bool | int | None = None,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Incrementally (append mode) write the buffer to HDF5 file.\n\n    Args:\n        path: Filename of the HDF5 file and optionally the path of the HDF5\n          group where the dataset is saved.\n        group: HDF5 group where to save the dataset. If it does not exist,\n          it is created.\n        data: Data to be written to the hdf5 file. If None, all files in\n          the buffer are written to HDF5 file.\n        expand_dim: Expand dimension of data array for stacking.\n        axis: Axis of the n-dimensional array where to append\n        overwrite: If data should overwrite indices in a pre-existing HDF5 dataset,\n          set to the index.\n        verbose: Print additional information to stdout.\n        kwargs: Additional keyword arguments for `Img2H5Buffer.configure_rdcc`,\n          h5py.File`, and/or `h5py.Group.create_dataset`.\n    \"\"\"\n    if path is None:\n        path = self.target\n    else:\n        path = Path(path)\n    if \":\" in str(path):\n        group = str(path).split(\":\")[1]\n        path = Path(str(path).split(\":\")[0])\n    if group.startswith(\"/\"):\n        group = group[1:]\n    if data is None:\n        data = self.flush()\n    if isinstance(data, np.ndarray) and expand_dim:\n        data = data[np.newaxis, ...]\n    if isinstance(overwrite, bool):\n        overwrite = 0 if overwrite else None\n    # configure HDF5 chunk caching\n    rdcc = {\"cache_size\": self.cache_size, \"verbose\": verbose}\n    for key in [\"f\", \"rdcc_nbytes\", \"rdcc_w0\", \"rdcc_nslots\"]:\n        if key in kwargs:\n            rdcc[key] = kwargs.pop(key)\n    rdcc = self.configure_rdcc(**rdcc)\n    # write metadata\n    if isinstance(data, dict):\n        file_kwargs, kwargs = self._h5py_file_kwargs(\n            kwargs,\n            defaults={\"mode\": \"a\", \"libver\": \"latest\"},\n        )\n        with h5py.File(path, **file_kwargs, **rdcc) as h5:\n            g = h5.create_group(f\"/{group}\") if group not in h5.keys() else h5[group]\n            for key in data:\n                g.attrs[key] = data[key]\n            if verbose:\n                print(\n                    f\"Data attribute(s) {tuple(data.keys())} have been \"\n                    f\"written to HDF5 file@[/{group}]\"\n                )\n    # write data\n    elif isinstance(data, np.ndarray):\n        file_kwargs, kwargs = self._h5py_file_kwargs(\n            kwargs,\n            defaults={\n                \"mode\": \"a\",\n                \"libver\": \"latest\",\n            },\n        )\n        kwargs, _ = self._h5py_create_dataset_kwargs(\n            kwargs | file_kwargs,\n            defaults={\n                \"compression\": \"gzip\",\n                \"shuffle\": True,\n                \"track_times\": True,\n                \"dtype\": data.dtype,\n                \"shape\": data.shape,\n                \"maxshape\": data.shape[:axis] + (None,) + data.shape[axis + 1 :],\n                \"chunks\": data.shape[:axis] + (1,) + data.shape[axis + 1 :],\n            },\n        )\n        with h5py.File(path, **file_kwargs, **rdcc) as h5:\n            ds_existed = isinstance(h5[group], H5Dataset) if group in h5 else False\n            ds = h5.require_dataset(group, **kwargs, **rdcc)\n            ds_samples = ds.shape[axis]\n            data_samples = data.shape[axis]\n            if not ds_existed:\n                self.index = 0\n            elif overwrite is None:\n                self.index = ds_samples\n                ds.resize(self.index + data_samples, axis=axis)\n            else:\n                self.index = overwrite\n                if data_samples &gt; ds_samples:\n                    ds.resize(self.index + data_samples, axis=axis)\n            slc = [slice(None)] * len(ds.shape)\n            slc[axis] = slice(self.index, self.index + data_samples)\n            ds[tuple(slc)] = data\n            if verbose:\n                print(\n                    f\"Data {data.shape} have been written to HDF5 dataset \"\n                    f\"{ds.shape}@({self.index}:{self.index + data_samples})\"\n                )\n    else:\n        warnings.warn(\n            \"Img2H5Buffer did not write data to file (either \"\n            \"because the buffer was empty or data was incompatible).\"\n        )\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.send","title":"send","text":"<pre><code>send(clear: bool = True) -&gt; np.ndarray | dict | None\n</code></pre> <p>Grab first data page from the buffer queue.</p> Source code in <code>skais_mapper/data.py</code> <pre><code>def send(self, clear: bool = True) -&gt; np.ndarray | dict | None:\n    \"\"\"Grab first data page from the buffer queue.\"\"\"\n    if self.queue:\n        if clear:\n            return self.queue.pop(0)\n        return self.page\n    elif self.files:\n        if clear:\n            self.store(self.files.pop(0))\n        else:\n            self.store(self.files[0])\n        return self.send(clear=True)\n    return None\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.store","title":"store","text":"<pre><code>store(\n    data: np.ndarray | dict | str | Path | list[str | Path],\n    squash: bool = True,\n) -&gt; Img2H5Buffer\n</code></pre> <p>Insert data into the buffer queue.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray | dict | str | Path | list[str | Path]</code> <p>Data to be stored in buffer.</p> required <code>squash</code> <code>bool</code> <p>Squash data dimensions if buffer data is compatible.</p> <code>True</code> Source code in <code>skais_mapper/data.py</code> <pre><code>def store(\n    self, data: np.ndarray | dict | str | Path | list[str | Path], squash: bool = True\n) -&gt; \"Img2H5Buffer\":\n    \"\"\"Insert data into the buffer queue.\n\n    Args:\n        data: Data to be stored in buffer.\n        squash: Squash data dimensions if buffer data is compatible.\n    \"\"\"\n    if (\n        squash\n        and isinstance(data, np.ndarray)\n        and self.queue\n        and isinstance(self.queue[-1], np.ndarray)\n    ):\n        try:\n            self.queue[-1] = np.concatenate((self.queue[-1], data))\n        except ValueError:\n            self.queue[-1] = ImgRead._stack_max_expand([self.queue[-1], data])\n    elif isinstance(data, np.ndarray | dict):\n        self.queue.append(data)\n    elif isinstance(data, str | Path) or (\n        isinstance(data, list) and isinstance(data[0], str | Path)\n    ):\n        return self.store(ImgRead()(data), squash=squash)\n    return self\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.Img2H5Buffer.write","title":"write","text":"<pre><code>write(\n    path: str | Path | None = None,\n    group: str = \"images\",\n    data: np.ndarray | dict | None = None,\n    verbose: bool = False,\n    **kwargs,\n)\n</code></pre> <p>Write all files in buffer to a new HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>Filename of the HDF5 file and optionally the path of the HDF5 group where the dataset is saved separated by a colon, e.g. <code>'/path/to/file.hdf5:/path/to/group'</code>.</p> <code>None</code> <code>group</code> <code>str</code> <p>HDF5 group where to save the dataset. If it does not exist, it is created.</p> <code>'images'</code> <code>data</code> <code>np.ndarray | dict | None</code> <p>Data to be written to the HDF5 file.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print additional information to stdout.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments for <code>h5py.Group.create_dataset</code>.</p> <code>{}</code> Source code in <code>skais_mapper/data.py</code> <pre><code>def write(\n    self,\n    path: str | Path | None = None,\n    group: str = \"images\",\n    data: np.ndarray | dict | None = None,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Write all files in buffer to a new HDF5 file.\n\n    Args:\n        path: Filename of the HDF5 file and optionally the path of the HDF5\n          group where the dataset is saved separated by a colon,\n          e.g. `'/path/to/file.hdf5:/path/to/group'`.\n        group: HDF5 group where to save the dataset. If it does not exist,\n          it is created.\n        data: Data to be written to the HDF5 file.\n        verbose: Print additional information to stdout.\n        kwargs: Additional keyword arguments for `h5py.Group.create_dataset`.\n    \"\"\"\n    self.inc_write(path, group=group, data=data, verbose=verbose, **kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.ImgRead","title":"ImgRead","text":"<p>Flexible image reader for multiple formats.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Automatically determine file type and read data appropriately.</p>"},{"location":"reference/skais_mapper/data/#skais_mapper.data.ImgRead.__call__","title":"__call__","text":"<pre><code>__call__(\n    paths: str | Path | list[str | Path] | None = None,\n    squash: bool = True,\n    pad_val: int | float = 0,\n    **kwargs,\n) -&gt; np.ndarray\n</code></pre> <p>Automatically determine file type and read data appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>str | Path | list[str | Path] | None</code> <p>File path to the image to be read.</p> <code>None</code> <code>squash</code> <code>bool</code> <p>If multiple paths are passed, merge and squash arrays.</p> <code>True</code> <code>pad_val</code> <code>int | float</code> <p>Padding value to be used for shape expansion if multiple paths are passed and images have different shape (default: 0).</p> <code>0</code> <code>**kwargs</code> <p>Additional keyword arguments for parser functions: <code>_read_npy</code>, <code>_read_png</code>, or <code>_read_jpg</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy ndarray of the image data.</p> Source code in <code>skais_mapper/data.py</code> <pre><code>def __call__(\n    self,\n    paths: str | Path | list[str | Path] | None = None,\n    squash: bool = True,\n    pad_val: int | float = 0,\n    **kwargs,\n) -&gt; np.ndarray:\n    \"\"\"Automatically determine file type and read data appropriately.\n\n    Args:\n        paths: File path to the image to be read.\n        squash: If multiple paths are passed, merge and squash arrays.\n        pad_val: Padding value to be used for shape expansion if multiple\n          paths are passed and images have different shape (default: 0).\n        **kwargs: Additional keyword arguments for parser functions:\n          `_read_npy`, `_read_png`, or `_read_jpg`.\n\n    Returns:\n        Numpy ndarray of the image data.\n    \"\"\"\n    if isinstance(paths, list | tuple):\n        data = [self(p, **kwargs) for p in tqdm(paths, desc=\"ImgRead\")]\n        if data and squash:\n            try:\n                data = np.concatenate(data)\n            except ValueError:\n                data = self._stack_max_expand(data, pad_val=0)\n        return data\n    filepath = Path(paths) if paths is not None else Path(\"\")\n    match filepath.suffix:\n        case \".npy\":\n            return self._read_npy(filepath, **kwargs)\n        case \".jpg\":\n            return self._read_jpg(filepath, **kwargs)\n        case \".png\":\n            return self._read_png(filepath, **kwargs)\n        case _:\n            return None\n</code></pre>"},{"location":"reference/skais_mapper/generate/","title":"skais_mapper.generate","text":""},{"location":"reference/skais_mapper/generate/#skais_mapper.generate","title":"skais_mapper.generate","text":"<p>Generate maps from simulations.</p> <p>Functions:</p> Name Description <code>map_TNG_galaxies</code> <p>Generate any number of maps from an IllustrisTNG snapshot(s).</p> <code>map_TNG_sample</code> <p>Project a subfind ID from an IllstrisTNG snapshot.</p> <code>run</code> <p>Main routine for generating any number of maps from a simulation snapshot(s)..</p>"},{"location":"reference/skais_mapper/generate/#skais_mapper.generate.map_TNG_galaxies","title":"map_TNG_galaxies","text":"<pre><code>map_TNG_galaxies(\n    snapshots: list[int],\n    gids: int | Iterable[int],\n    groups: list[str] | None = None,\n    output: str | None = None,\n    src_dir: str | None = None,\n    sim_type: str = \"illustris/tng50-1\",\n    csv_file: str | Path | None = None,\n    part_max: int | None = None,\n    part_min: int | None = 20000,\n    retries: int | None = None,\n    subfind_limit: int | None = 15000,\n    grid_size: int = 512,\n    rotations: np.ndarray | None = None,\n    random_rotations: bool = True,\n    rng_seed: int = 42,\n    dry_run: bool = False,\n    verbose: bool = True,\n)\n</code></pre> <p>Generate any number of maps from an IllustrisTNG snapshot(s).</p> <p>Parameters:</p> Name Type Description Default <code>snapshots</code> <code>list[int]</code> <p>Snapshots number of the IllustrisTNG run.</p> required <code>gids</code> <code>int | Iterable[int]</code> <p>Subfind IDs, i.e. galaxies, from which to generate maps.</p> required <code>groups</code> <code>list[str] | None</code> <p>Galaxy properties to map, e.g. star, gas, or dm.</p> <code>None</code> <code>output</code> <code>str | None</code> <p>Output filename. Can have format fields '{}' for group and snapshot.</p> <code>None</code> <code>src_dir</code> <code>str | None</code> <p>Path to the root of the simulation snapshots.</p> <code>None</code> <code>sim_type</code> <code>str</code> <p>Simulation type (should correspond to the subpath in <code>src_dir</code>).</p> <code>'illustris/tng50-1'</code> <code>csv_file</code> <code>str | Path | None</code> <p>Path the the CSV file used for logging supplemental information.</p> <code>None</code> <code>part_max</code> <code>int | None</code> <p>Maximum number of particles to use for map generation.</p> <code>None</code> <code>part_min</code> <code>int | None</code> <p>Minimum number of particles to use for map generation.</p> <code>20000</code> <code>retries</code> <code>int | None</code> <p>If not None, sets the maximum number of replacement candidates for skipped groups.</p> <code>None</code> <code>subfind_limit</code> <code>int | None</code> <p>If not None, sets the maximum subfind ID allowed as replacement.</p> <code>15000</code> <code>grid_size</code> <code>int</code> <p>The size of the maps/images. Default: 512.</p> <code>512</code> <code>rotations</code> <code>np.ndarray | None</code> <p>List of angle pairs (theta, phi) per rotation for each subfind ID; e.g. for 4 separate rotations per subfind ID, its shape is (len(gids), 4, 2).</p> <code>None</code> <code>random_rotations</code> <code>bool</code> <p>If True, use random rotations (2 per subfind ID) to augment the dataset.</p> <code>True</code> <code>rng_seed</code> <code>int</code> <p>Random number seed.</p> <code>42</code> <code>dry_run</code> <code>bool</code> <p>If True, nothing is saved and expensive computation is skipped.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print status updates to command line.</p> <code>True</code> Source code in <code>skais_mapper/generate.py</code> <pre><code>def map_TNG_galaxies(\n    snapshots: list[int],\n    gids: int | Iterable[int],\n    groups: list[str] | None = None,\n    output: str | None = None,\n    src_dir: str | None = None,\n    sim_type: str = \"illustris/tng50-1\",\n    csv_file: str | Path | None = None,\n    part_max: int | None = None,\n    part_min: int | None = 20_000,\n    retries: int | None = None,\n    subfind_limit: int | None = 15_000,\n    grid_size: int = 512,\n    rotations: np.ndarray | None = None,\n    random_rotations: bool = True,\n    rng_seed: int = 42,\n    dry_run: bool = False,\n    verbose: bool = True,\n):\n    \"\"\"Generate any number of maps from an IllustrisTNG snapshot(s).\n\n    Args:\n        snapshots: Snapshots number of the IllustrisTNG run.\n        gids: Subfind IDs, i.e. galaxies, from which to generate maps.\n        groups: Galaxy properties to map, e.g. star, gas, or dm.\n        output: Output filename. Can have format fields '{}' for group and snapshot.\n        src_dir: Path to the root of the simulation snapshots.\n        sim_type: Simulation type (should correspond to the subpath in `src_dir`).\n        csv_file: Path the the CSV file used for logging supplemental information.\n        part_max: Maximum number of particles to use for map generation.\n        part_min: Minimum number of particles to use for map generation.\n        retries: If not None, sets the maximum number of replacement candidates for skipped groups.\n        subfind_limit: If not None, sets the maximum subfind ID allowed as replacement.\n        grid_size: The size of the maps/images. Default: 512.\n        rotations: List of angle pairs (theta, phi) per rotation for each subfind ID;\n          e.g. for 4 separate rotations per subfind ID, its shape is (len(gids), 4, 2).\n        random_rotations: If True, use random rotations (2 per subfind ID) to\n          augment the dataset.\n        rng_seed: Random number seed.\n        dry_run: If True, nothing is saved and expensive computation is skipped.\n        verbose: If True, print status updates to command line.\n    \"\"\"\n    snapshots = list(snapshots)\n    gids = list(range(gids)) if isinstance(gids, int) else list(gids)\n    # list of groups to generate\n    if groups is None:\n        groups = [\"gas\"]\n    Ng = len(gids) * len(groups)\n    skip_count = [0] * (Ng // len(groups))\n    # gather paths\n    src_path = Path(src_dir) if src_dir is not None else Path(\"./simulations\")\n    tng_path = src_path / sim_type\n    if output is None:\n        hdf5_file = Path(\n            str(datetime.datetime.now().date()).replace(\"-\", \"\")\n            + f\"_{tng_path.name}.{{}}.2D.{{}}.hdf5\"\n        )\n    else:\n        hdf5_file = Path(output)\n    if csv_file is None:\n        csv_file = hdf5_file.parent / f\"{get_run_id()}.group_particles.csv\"\n    if not csv_file.exists() and not dry_run:\n        csv_file.parent.mkdir(parents=True, exist_ok=True)\n        with csv_file.open(mode=\"w\", newline=\"\") as fcsv:\n            writer = csv.writer(fcsv)\n            writer.writerow(\n                [\n                    \"snapshot\",\n                    \"gid\",\n                    \"N_particles_gas\",\n                    \"N_particles_dm\",\n                    \"N_particles_stars\",\n                    \"N_particles_bh\",\n                ]\n            )\n\n    # Resolve paths and verify existance\n    print(\"Resolved paths:\")\n    print(\"Source path:\", src_path.resolve())\n    print(f\"{src_path.resolve()}: exists\", src_path.exists())\n    print(\"tng50-1:    \", tng_path.resolve())\n    print(f\"{tng_path.resolve()}: exists\", tng_path.exists())\n    print(\"Output:     \", hdf5_file)\n\n    # Precompute all rotations\n    if random_rotations:\n        rng = np.random.default_rng(rng_seed)\n        N_rot = Ng\n        rotations = np.stack(\n            (\n                rng.integers(25, 180, size=N_rot),\n                rng.integers(25, 90, size=N_rot),\n                rng.integers(90, 270, size=N_rot),\n            )\n        )\n        rotations = np.vstack(\n            (\n                rotations,\n                rotations[0] + rng.integers(20, 40, size=N_rot),\n                rotations[1] + rng.integers(70, 110, size=N_rot),\n                rotations[2] + rng.integers(40, 90, size=N_rot),\n            )\n        ).T.reshape(Ng, 3, 2)\n\n    # Generation loop\n    for snap_id in snapshots:\n        # run through galaxies\n        for i, gid in enumerate(gids):\n            if Ng &lt; 0:\n                break\n            angles = [] if rotations is None else rotations[i]\n            for j, group in enumerate(groups):\n                p_group = group if group in [\"gas\", \"star\", \"dm\"] else \"gas\"\n                tng_src = TNGGalaxy(\n                    tng_path,\n                    snap_id,\n                    halo_index=gids[0],\n                    particle_type=p_group,\n                    as_float32=True,\n                    verbose=True,\n                )\n                if gid != tng_src.halo_index:\n                    tng_src.halo_index = gid\n                if p_group != tng_src.particle_type:\n                    tng_src.particle_type = group\n                print(f\"\\n# Snapshot {snap_id}, subhalo {gid}, {group}\")\n                # check if number of particles in halo is within accepted range\n                if (part_max is not None and part_max &lt; tng_src.N_particles_type[0]) or (\n                    part_min is not None and tng_src.N_particles_type[0] &lt; part_min\n                ):\n                    if verbose:\n                        print(\n                            \"Skipping candidate due to low particle number\"\n                            f\" {tng_src.N_particles_type[0]}...\"\n                        )\n                    # add another group candidate below the limit\n                    if retries is not None and skip_count[-1] &gt;= retries:\n                        Ng -= 1\n                    elif subfind_limit is not None:\n                        while gid in gids and gid &lt;= subfind_limit:\n                            gid += 1\n                        gids.append(gid)\n                        if rotations is not None:\n                            rotations = np.concatenate(\n                                (rotations, rotations[i][np.newaxis, ...]), axis=0\n                            )\n                        skip_count.append(skip_count[-1] + 1)\n                    break\n                Ng -= 1\n\n                # construct actual hdf5 filename\n                if str(hdf5_file).count(\"{\") == 2:\n                    out_hdf5 = Path(str(hdf5_file).format(snap_id, group.replace(\"/\", \".\")))\n                elif str(hdf5_file).count(\"{\") == 1:\n                    out_hdf5 = Path(str(hdf5_file).format(group.replace(\"/\", \".\")))\n                else:\n                    out_hdf5 = hdf5_file\n                # generate maps, plots, and save to files\n                map_TNG_sample(\n                    tng_src,\n                    gid,\n                    group=group,\n                    hdf5_file=out_hdf5,\n                    grid_size=grid_size,\n                    fh=3 if group == \"dm\" else 2 if group == \"star\" else 1,\n                    rng_seed=rng_seed,\n                    rot=None,\n                    hdf5_save=True,\n                    npy_save=True,\n                    png_save=True,\n                    subdir_save=True,\n                    dry_run=dry_run,\n                    verbose=verbose,\n                )\n                for theta, phi in angles:\n                    map_TNG_sample(\n                        tng_src,\n                        gid,\n                        group=group,\n                        hdf5_file=out_hdf5,\n                        grid_size=grid_size,\n                        fh=3 if group == \"dm\" else 2 if group == \"star\" else 1,\n                        rng_seed=rng_seed,\n                        rot=(theta, phi),\n                        hdf5_save=True,\n                        npy_save=True,\n                        png_save=True,\n                        subdir_save=True,\n                        dry_run=dry_run,\n                        verbose=verbose,\n                    )\n            if csv_file.exists():\n                with open(csv_file, \"a\", newline=\"\") as fcsv:\n                    writer = csv.writer(fcsv)\n                    writer.writerow(\n                        [snap_id]\n                        + [gid]\n                        + tng_src.N_particles_type[0:2]\n                        + tng_src.N_particles_type[4:],\n                    )\n            if verbose:\n                print(\n                    f\"Number of particles in group: {tng_src.N_particles_type[0]} [gas]\"\n                    f\" | {tng_src.N_particles_type[tng_src.p_idx]} [{group}]\"\n                )\n            gc.collect()\n</code></pre>"},{"location":"reference/skais_mapper/generate/#skais_mapper.generate.map_TNG_sample","title":"map_TNG_sample","text":"<pre><code>map_TNG_sample(\n    obj: TNGGalaxy,\n    gid: int,\n    group: str = \"gas\",\n    projected_unit: au.Unit = None,\n    cmap: Colormap | None = None,\n    hdf5_file: str | Path | None = None,\n    hdf5_save: bool = True,\n    npy_save: bool = False,\n    png_save: bool = False,\n    subdir_save: bool = False,\n    grid_size: int = 512,\n    fh: float = 3,\n    rot: list[float] | tuple[float, float] | None = None,\n    xaxis: int = 0,\n    yaxis: int = 1,\n    periodic: bool = False,\n    rng_seed: int = 42,\n    flag_lim: float = 0,\n    flag_N: int = 64,\n    post_hook: Callable | None = None,\n    dry_run: bool = False,\n    verbose: bool = True,\n)\n</code></pre> <p>Project a subfind ID from an IllstrisTNG snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>TNGGalaxy</code> <p>Instance at a set snapshot, pointing at set subfind ID.</p> required <code>gid</code> <code>int</code> <p>Galaxy/halo index.</p> required <code>group</code> <code>str</code> <p>Galaxy property of the map, one of [gas,star,gas,hi,hi/21cm,temp,bfield].</p> <code>'gas'</code> <code>projected_unit</code> <code>au.Unit</code> <p>Units in which the map is to be projected.</p> <code>None</code> <code>cmap</code> <code>Colormap | None</code> <p>Colormap for map plot.</p> <code>None</code> <code>hdf5_file</code> <code>str | Path | None</code> <p>Basename of the HDF5 file.</p> <code>None</code> <code>hdf5_save</code> <code>bool</code> <p>If True, save map to HDF5 file.</p> <code>True</code> <code>npy_save</code> <code>bool</code> <p>If True, save map as numpy binary files.</p> <code>False</code> <code>png_save</code> <code>bool</code> <p>If True, save map plot as PNG file.</p> <code>False</code> <code>subdir_save</code> <code>bool</code> <p>If True, saves numpy binary and PNG files in corresponding subdirectories.</p> <code>False</code> <code>grid_size</code> <code>int</code> <p>The size of the maps/images. Default: 512.</p> <code>512</code> <code>fh</code> <code>float</code> <p>Expansion factor for the SPH particle radii.</p> <code>3</code> <code>rot</code> <code>list[float] | tuple[float, float] | None</code> <p>Angles by which the sample is rotated before projection.</p> <code>None</code> <code>xaxis</code> <code>int</code> <p>Projection axis for x.</p> <code>0</code> <code>yaxis</code> <code>int</code> <p>Projection axis for y.</p> <code>1</code> <code>periodic</code> <code>bool</code> <p>Use periodic boundary conditions for the projection (for metadata).</p> <code>False</code> <code>rng_seed</code> <code>int</code> <p>Seed for the random number generation.</p> <code>42</code> <code>flag_lim</code> <code>float</code> <p>Flag the map in the metadata if N pixel values fall below the limit.</p> <code>0</code> <code>flag_N</code> <code>int</code> <p>The number of pixels before an image is flagged.</p> <code>64</code> <code>post_hook</code> <code>Callable | None</code> <p>Post projection callback function to, e.g., rescale the map.</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>If True, nothing is saved and expensive computation is skipped.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print status updates to command line.</p> <code>True</code> Source code in <code>skais_mapper/generate.py</code> <pre><code>def map_TNG_sample(\n    obj: TNGGalaxy,\n    gid: int,\n    group: str = \"gas\",\n    projected_unit: au.Unit = None,\n    cmap: Colormap | None = None,\n    hdf5_file: str | Path | None = None,\n    hdf5_save: bool = True,\n    npy_save: bool = False,\n    png_save: bool = False,\n    subdir_save: bool = False,\n    grid_size: int = 512,\n    fh: float = 3,\n    rot: list[float] | tuple[float, float] | None = None,\n    xaxis: int = 0,\n    yaxis: int = 1,\n    periodic: bool = False,\n    rng_seed: int = 42,\n    flag_lim: float = 0,\n    flag_N: int = 64,\n    post_hook: Callable | None = None,\n    dry_run: bool = False,\n    verbose: bool = True,\n):\n    \"\"\"Project a subfind ID from an IllstrisTNG snapshot.\n\n    Args:\n        obj: Instance at a set snapshot, pointing at set subfind ID.\n        gid: Galaxy/halo index.\n        group: Galaxy property of the map, one of [gas,star,gas,hi,hi/21cm,temp,bfield].\n        projected_unit: Units in which the map is to be projected.\n        cmap: Colormap for map plot.\n        hdf5_file: Basename of the HDF5 file.\n        hdf5_save: If True, save map to HDF5 file.\n        npy_save: If True, save map as numpy binary files.\n        png_save: If True, save map plot as PNG file.\n        subdir_save: If True, saves numpy binary and PNG files in corresponding subdirectories.\n        grid_size: The size of the maps/images. Default: 512.\n        fh: Expansion factor for the SPH particle radii.\n        rot: Angles by which the sample is rotated before projection.\n        xaxis: Projection axis for x.\n        yaxis: Projection axis for y.\n        periodic: Use periodic boundary conditions for the projection (for metadata).\n        rng_seed: Seed for the random number generation.\n        flag_lim: Flag the map in the metadata if N pixel values fall below the limit.\n        flag_N: The number of pixels before an image is flagged.\n        post_hook: Post projection callback function to, e.g., rescale the map.\n        dry_run: If True, nothing is saved and expensive computation is skipped.\n        verbose: If True, print status updates to command line.\n    \"\"\"\n    # gather settings\n    kwargs: dict[str, Any] = {\n        \"use_half_mass_rad\": True,\n        \"fh\": fh,\n        \"grid_size\": grid_size,\n        \"xaxis\": xaxis,\n        \"yaxis\": yaxis,\n        \"periodic\": periodic,\n        \"rot\": rot,\n        \"verbose\": verbose,\n    }\n    # set up configs for group\n    if group == \"gas\":\n        kwargs[\"keys\"] = [\"particle_positions\", \"masses\", \"radii\", \"center\"]\n        if projected_unit is None:\n            projected_unit = au.Msun / au.kpc**2\n    elif group == \"hi\":\n        kwargs[\"keys\"] = [\"particle_positions\", \"m_HI\", \"radii\", \"center\"]\n        if projected_unit is None:\n            projected_unit = au.Msun / au.kpc**2\n    elif group == \"hi/21cm\":\n        kwargs[\"keys\"] = [\"particle_positions\", \"m_HI\", \"radii\", \"center\"]\n        kwargs[\"assignment_func\"] = voronoi_NGP_2D\n        kwargs[\"tracers\"] = 128\n        kwargs[\"divisions\"] = 2\n        pixel_size = 1.0 / grid_size\n        z, h, H0, Hz = (\n            obj.cosmology.z,\n            obj.cosmology.h,\n            obj.cosmology.H0,\n            obj.cosmology.H(obj.cosmology.a),\n        )\n        sigma_crit = obj.cosmology.rho_crit\n\n        def post_hook_21cm(x, y):\n            return (\n                189\n                * au.mK\n                * h\n                * (1 + z) ** 2\n                * (H0 / Hz)\n                * x\n                / ((y[1] - y[0]) * pixel_size * sigma_crit)\n            )\n\n        if post_hook is None:\n            post_hook = post_hook_21cm\n        if projected_unit is None:\n            projected_unit = au.mK\n        flag_lim, flag_N = 0, int(grid_size**2 / 10)\n    elif group == \"temp\":\n        kwargs[\"keys\"] = [\n            \"particle_positions\",\n            (\"masses\", \"temperature\"),\n            \"radii\",\n            \"center\",\n        ]\n        if projected_unit is None:\n            projected_unit = au.K\n    elif group == \"bfield\":\n        kwargs[\"keys\"] = [\n            \"particle_positions\",\n            (\"masses\", \"magnetic_field_strength\"),\n            \"radii\",\n            \"center\",\n        ]\n        if projected_unit is None:\n            projected_unit = au.Gauss\n    elif group == \"star\":\n        kwargs[\"keys\"] = [\"particle_positions\", \"masses\", \"radii\", \"center\"]\n        if projected_unit is None:\n            projected_unit = au.Msun / au.kpc**2\n    elif group == \"dm\":\n        kwargs[\"keys\"] = [\"particle_positions\", \"masses\", \"radii\", \"center\"]\n        if projected_unit is None:\n            projected_unit = au.Msun / au.kpc**2\n    else:\n        raise ValueError(f\"Map group type {group} is not known.\")\n    if isinstance(kwargs[\"keys\"][1], tuple | list):\n        keys = kwargs.pop(\"keys\")\n        quantity, extent, N = obj.generate_map(keys=keys, **kwargs)\n        keys[1] = keys[1][0]\n        weight_map, _, _ = obj.generate_map(keys=keys, **kwargs)\n        projected = np.zeros_like(quantity.value)\n        np.place(\n            projected,\n            weight_map.value != 0,\n            quantity.value[weight_map.value != 0] / weight_map.value[weight_map.value != 0],\n        )\n        projected *= quantity.unit / weight_map.unit\n    else:\n        # allocate arrays and raytrace\n        projected, extent, N = obj.generate_map(**kwargs)\n    if post_hook is not None:\n        projected = post_hook(projected, extent)\n    # convert to chosen units\n    projected = projected.to(projected_unit)\n    # check for potential problems\n    flag = 0\n    if np.sum(projected.value &lt; flag_lim) &gt; flag_N:\n        print(\"Potential issue with projection, flagging image...\")\n        flag = 1\n    has_bh = obj.N_particles_type[-1]\n    # plot data\n    rot_str = f\"_rotxy.{rot[0]}.{rot[1]}\" if rot is not None else \"\"\n    bname = f\"{str(Path(group).stem)}_tng50-1.{obj.snapshot:02d}.gid.{obj.halo_index:07d}{rot_str}\"\n    md = {\n        \"class\": group,\n        \"gid\": obj.halo_index,\n        \"snapshot\": obj.snapshot,\n        \"units\": f\"{projected.unit}\",\n        \"extent\": extent.value,\n        \"units_extent\": f\"{extent.unit}\",\n        \"name\": bname,\n        \"num_particles\": N,\n        \"rotxy\": rot if rot is not None else (0, 0),\n        \"N_particle_flag\": flag,\n        \"has_bh\": has_bh,\n        \"rng_seed\": rng_seed,\n    }\n    plot_image(\n        projected,\n        info=md,\n        cbar=True,\n        norm=\"log\" if group != \"hi/21cm\" else None,\n        savefig=png_save and not dry_run,\n        path=hdf5_file.parent / group / \"png\" / f\"{bname}.png\"\n        if subdir_save\n        else hdf5_file.parent / f\"{bname}.png\",\n        show=dry_run,\n        close=not dry_run,\n        verbose=verbose\n    )\n    # save data\n    if npy_save:\n        npname = f\"{bname}.units.{projected.unit}.extent.{extent[1] - extent[0]:4.8f}.npy\".replace(\n            \" \", \"\"\n        ).replace(\"/\", \"_\")\n        np_dir = hdf5_file.parent\n        if subdir_save:\n            np_dir = np_dir / group / \"npy\"\n        if not dry_run:\n            if not np_dir.exists():\n                np_dir.mkdir(parents=True)\n            np.save(np_dir / npname, projected.value)\n        if verbose:\n            print(f\"Saving to [npy]: {np_dir / npname}\")\n    if hdf5_save and hdf5_file is not None:\n        if subdir_save:\n            hdf5_file = hdf5_file.parent / group / \"hdf5\" / hdf5_file.name\n            if not hdf5_file.parent.exists() and not dry_run:\n                hdf5_file.parent.mkdir(parents=True)\n        img2h5 = Img2H5Buffer(target=hdf5_file, size=\"2G\")\n        img_target = f\"{str(hdf5_file)}\"\n        mdt_target = f\"{str(hdf5_file)}\"\n        img_h5group = f\"{group}/images\"\n        mdt_h5group = f\"{group}/metadata/\"\n        if not dry_run:\n            img_h5group = f\"{group}/images\"\n            img2h5.inc_write(img_target, data=projected.value, group=img_h5group, verbose=verbose)\n            mdt_h5group = f\"{group}/metadata/{img2h5.index:04d}\"\n            img2h5.inc_write(mdt_target, data=md, group=mdt_h5group, verbose=verbose)\n        if verbose:\n            print(f\"Saving to [hdf5]: {img_target}:{img_h5group}\")\n            print(f\"Saving to [hdf5]: {mdt_target}:{mdt_h5group}\")\n</code></pre>"},{"location":"reference/skais_mapper/generate/#skais_mapper.generate.run","title":"run","text":"<pre><code>run(cfg: DictConfig | dict)\n</code></pre> <p>Main routine for generating any number of maps from a simulation snapshot(s)..</p> Source code in <code>skais_mapper/generate.py</code> <pre><code>@hydra.main(config_path=\"configs\", config_name=\"config\", version_base=None)\ndef run(cfg: DictConfig | dict):\n    \"\"\"Main routine for generating any number of maps from a simulation snapshot(s)..\"\"\"\n    log = logging.getLogger(__name__)\n    output_dir = HydraConfig.get().runtime.output_dir\n    opt = instantiate(cfg, _convert_=\"all\")\n    if not cfg.exclude_git_state:\n        log.info(f\"Git state: {skais_mapper.GIT_STATE}\")\n    if cfg.include_git_diff:\n        for d in skais_mapper.GIT_DIFF:\n            log.info(f\"Git diff: {compress_encode(d)}\")\n    log.info(f\"Job id: {opt['run_id']}\")\n    log.info(f\"Output directory: {output_dir}\")\n    if cfg.verbose:\n        print(\"Configuration:\")\n        print(OmegaConf.to_yaml(cfg))\n\n    if cfg.save_configs:\n        hydra_subdir = Path(HydraConfig.get().output_subdir)\n        src_file = hydra_subdir / \"config.yaml\"\n        dst_file = Path(opt[\"output\"])\n        if dst_file.suffix not in [\".yaml\", \".yml\"]:\n            dst_file = Path(f\"./{opt['run_id']}.yaml\")\n        dst_file.write_bytes(src_file.read_bytes())\n\n    if \"tng\" in opt[\"simulation_type\"].lower():\n        np.random.seed(opt[\"random_seed\"])\n        map_TNG_galaxies(\n            opt[\"snapshots\"],\n            range(*opt[\"num_samples\"]),\n            groups=opt[\"groups\"],\n            sim_type=opt[\"simulation_type\"],\n            output=opt[\"output\"],\n            src_dir=opt[\"source\"],\n            part_min=opt[\"part_min\"],\n            retries=opt[\"retries\"],\n            subfind_limit=opt[\"subfind_limit\"],\n            rng_seed=opt[\"random_seed\"],\n            grid_size=opt[\"grid_size\"],\n            dry_run=opt[\"dry_run\"],\n            verbose=opt[\"verbose\"],\n        )\n</code></pre>"},{"location":"reference/skais_mapper/illustris/","title":"skais_mapper.illustris","text":""},{"location":"reference/skais_mapper/illustris/#skais_mapper.illustris","title":"skais_mapper.illustris","text":"<p>All illustris utilities for loading simulation data.</p> <p>Adapted from: https://github.com/illustristng/illustris_python</p> <p>Modules:</p> Name Description <code>groupcat</code> <p>Illustris file i/o for FoF and Subfind group catalog.</p> <code>snapshots</code> <p>Illustris simulation snapshot file i/o.</p> <code>util</code> <p>Illustris simulation snapshot utilities.</p>"},{"location":"reference/skais_mapper/illustris/groupcat/","title":"skais_mapper.illustris.groupcat","text":""},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat","title":"skais_mapper.illustris.groupcat","text":"<p>Illustris file i/o for FoF and Subfind group catalog.</p> <p>Adapted from: https://github.com/illustristng/illustris_python</p> <p>Functions:</p> Name Description <code>get_offset_path</code> <p>Get absolute path to a separate offset file (modify as needed).</p> <code>get_path</code> <p>Get absolute path to a group catalog HDF5 file (modify as needed).</p> <code>load</code> <p>Load complete group catalog all at once.</p> <code>load_catalog</code> <p>Load either halo or subhalo information from the group catalog.</p> <code>load_group</code> <p>Load a specified HDF5 group from a group catalog.</p> <code>load_halos</code> <p>Load all halo information from the entire group catalog for one snapshot.</p> <code>load_header</code> <p>Load the header of a group catalog.</p> <code>load_single</code> <p>Fetch the complete group catalog information for a single halo or subhalo.</p> <code>load_subhalos</code> <p>Load all subhalo information from the entire group catalog for one snapshot.</p>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.get_offset_path","title":"get_offset_path","text":"<pre><code>get_offset_path(\n    base_path: str, snapshot: int, *args\n) -&gt; str\n</code></pre> <p>Get absolute path to a separate offset file (modify as needed).</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>*args</code> <p>Dummy arguments for compatibility.</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>Absolute path to a group catalog's offsets HDF5 file.</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def get_offset_path(base_path: str, snapshot: int, *args) -&gt; str:\n    \"\"\"Get absolute path to a separate offset file (modify as needed).\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        *args: Dummy arguments for compatibility.\n\n    Returns:\n        (str): Absolute path to a group catalog's offsets HDF5 file.\n    \"\"\"\n    basename = f\"offsets/offsets_{snapshot:03d}.hdf5\"\n    offset_path = os.path.join(base_path, basename)\n    return offset_path\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.get_path","title":"get_path","text":"<pre><code>get_path(\n    base_path: str, snapshot: int, partition: int = 0\n) -&gt; str\n</code></pre> <p>Get absolute path to a group catalog HDF5 file (modify as needed).</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}</p> required <code>partition</code> <code>int</code> <p>Subfile partition ID {0-600+}</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>Absolute path to a group catalog HDF5 file</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def get_path(base_path: str, snapshot: int, partition: int = 0) -&gt; str:\n    \"\"\"Get absolute path to a group catalog HDF5 file (modify as needed).\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots\n        snapshot: Snapshot ID {0-99}\n        partition: Subfile partition ID {0-600+}\n\n    Returns:\n        (str): Absolute path to a group catalog HDF5 file\n    \"\"\"\n    gc_dir = os.path.join(base_path, f\"groupcats/{snapshot:03d}\")\n    filepath = os.path.join(gc_dir, f\"groups_{snapshot:03d}.{partition:d}.hdf5\")\n    filepath_alt = filepath.replace(\"groups_\", \"fof_subhalo_tab_\")\n    if os.path.isfile(filepath):\n        return filepath\n    return filepath_alt\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.load","title":"load","text":"<pre><code>load(\n    base_path,\n    snapshot,\n    subhalos_kwargs: dict = None,\n    halos_kwargs: dict = None,\n    header_kwargs: dict = None,\n    **kwargs,\n) -&gt; dict\n</code></pre> <p>Load complete group catalog all at once.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <p>Snapshot ID {0-99}.</p> required <code>subhalos_kwargs</code> <code>dict</code> <p>Keyword arguments for loading subhalos.</p> <code>None</code> <code>halos_kwargs</code> <code>dict</code> <p>Keyword arguments for loading halos.</p> <code>None</code> <code>header_kwargs</code> <code>dict</code> <p>Keyword arguments for loading the header.</p> <code>None</code> <code>**kwargs</code> <p>Additional </p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the loaded data</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def load(\n    base_path,\n    snapshot,\n    subhalos_kwargs: dict = None,\n    halos_kwargs: dict = None,\n    header_kwargs: dict = None,\n    **kwargs,\n) -&gt; dict:\n    \"\"\"Load complete group catalog all at once.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        subhalos_kwargs: Keyword arguments for loading subhalos.\n        halos_kwargs: Keyword arguments for loading halos.\n        header_kwargs: Keyword arguments for loading the header.\n        **kwargs: Additional \n\n    Returns:\n        (dict): A dictionary of the loaded data\n    \"\"\"\n    data = kwargs\n    if subhalos_kwargs is None:\n        subhalos_kwargs = {}\n    if halos_kwargs is None:\n        halos_kwargs = {}\n    if header_kwargs is None:\n        header_kwargs = {}\n    data[\"subhalos\"] = load_subhalos(base_path, snapshot, **subhalos_kwargs)\n    data[\"halos\"] = load_halos(base_path, snapshot, **halos_kwargs)\n    data[\"header\"] = load_header(base_path, snapshot, **header_kwargs)\n    return data\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.load_catalog","title":"load_catalog","text":"<pre><code>load_catalog(\n    base_path: str,\n    snapshot: int,\n    key: str,\n    key_ref: str,\n    fields: list = None,\n    as_float32: bool = False,\n    as_array: bool = True,\n    with_pbar: bool = True,\n) -&gt; dict | NDArray\n</code></pre> <p>Load either halo or subhalo information from the group catalog.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>key</code> <code>str</code> <p>Group name from the HDF5 group catalog, e.g. 'Group' or 'Subhalo'.</p> required <code>key_ref</code> <code>str</code> <p>Group name reference string in the HDF5 group catalog's header keys, e.g. 'groups' or 'subgroups'/'subhalos'</p> required <code>fields</code> <code>list</code> <p>Fields to be loaded for the corresponding group, e.g. ['GroupPos', 'GroupMass'] or 'SubhaloGasMetalFractions'.</p> <code>None</code> <code>as_float32</code> <code>bool</code> <p>Load float64 data types as float32 (to save memory).</p> <code>False</code> <code>as_array</code> <code>bool</code> <p>Return a numpy array instead of a dictionary; takes effect only if a single field was requested.</p> <code>True</code> <code>with_pbar</code> <code>bool</code> <p>If True, a progress bar will show the current status.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict | numpy.ndarray</code> <p>A dictionary of the loaded data</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def load_catalog(\n    base_path: str,\n    snapshot: int,\n    key: str,\n    key_ref: str,\n    fields: list = None,\n    as_float32: bool = False,\n    as_array: bool = True,\n    with_pbar: bool = True,\n) -&gt; dict | NDArray:\n    \"\"\"Load either halo or subhalo information from the group catalog.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        key: Group name from the HDF5 group catalog, e.g. 'Group' or 'Subhalo'.\n        key_ref: Group name reference string in the HDF5 group catalog's\n          header keys, e.g. 'groups' or 'subgroups'/'subhalos'\n        fields: Fields to be loaded for the corresponding group,\n          e.g. ['GroupPos', 'GroupMass'] or 'SubhaloGasMetalFractions'.\n        as_float32: Load float64 data types as float32 (to save memory).\n        as_array: Return a numpy array instead of a dictionary; takes\n          effect only if a single field was requested.\n        with_pbar: If True, a progress bar will show the current status.\n\n    Returns:\n        (dict | numpy.ndarray): A dictionary of the loaded data\n    \"\"\"\n    data = {}\n    if fields is None:\n        fields = []\n    elif isinstance(fields, str | bytes):\n        fields = [fields]\n    # load header from first partition\n    IllustrisH5File.path_func = get_path\n    header = load_header(base_path, snapshot)\n    group = load_group(base_path, snapshot, key)\n    if f\"N{key_ref}_Total\" not in header and key_ref == \"subgroups\":\n        key_ref = \"subhalos\"\n    data[\"count\"] = header.get(f\"N{key_ref}_Total\", None)\n    if not data[\"count\"]:\n        print(f\"Warning: zero groups, empty return (snap='{snapshot}').\")\n        return data\n    if not fields:\n        fields = list(group.keys())\n    for field in fields:\n        if field not in group.keys():\n            raise KeyError(f\"Group catalog does not have requested field [{field}]!\")\n        # replace local length with global\n        shape = list(group[field].shape)\n        shape[0] = data[\"count\"]\n        dtype = group[field].dtype\n        if dtype == np.float64 and as_float32:\n            dtype = np.float32\n        # allocate data arrays\n        data[field] = np.zeros(shape, dtype=dtype)\n    group._id.close()\n    # loop over partitions\n    arr_offset = 0\n    if with_pbar:\n        partition_iterator = trange(header[\"NumFiles\"])\n    else:\n        partition_iterator = range(header[\"NumFiles\"])\n    for i in partition_iterator:\n        f = IllustrisH5File(base_path, snapshot, i)\n        # if partition is empty\n        if not f[\"Header\"].attrs[f\"N{key_ref}_ThisFile\"]:\n            continue\n        # loop over each field\n        for field in fields:\n            if field not in f[key].keys():\n                raise KeyError(f\"Group catalog does not have requested field [{field}]!\")\n            # shape and type\n            shape = f[key][field].shape\n            if len(shape) == 1:\n                data[field][arr_offset : arr_offset + shape[0]] = f[key][field][0 : shape[0]]\n            else:\n                data[field][arr_offset : arr_offset + shape[0], :] = f[key][field][0 : shape[0], :]\n        arr_offset += shape[0]\n        f.close()\n    if as_array and len(fields) == 1:\n        return data[fields[0]]\n    return data\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.load_group","title":"load_group","text":"<pre><code>load_group(\n    base_path: str,\n    snapshot: int,\n    key: str,\n    as_dict: bool = False,\n) -&gt; dict | h5py.Group\n</code></pre> <p>Load a specified HDF5 group from a group catalog.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>key</code> <code>str</code> <p>Group descriptor, i.e. a group from the HDF5 catalog e.g. 'Group' or 'Subhalo'.</p> required <code>as_dict</code> <code>bool</code> <p>If True, a dictionary is returned, otherwise as h5py.Group object.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>The HDF5 group from the group catalog HDF5 file as a dictionary</p> <p>Note: Remember to close the HDF5 file afterwards (use ._id.close()). Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def load_group(base_path: str, snapshot: int, key: str, as_dict: bool = False) -&gt; dict | h5py.Group:\n    \"\"\"Load a specified HDF5 group from a group catalog.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        key: Group descriptor, i.e. a group from the HDF5 catalog\n          e.g. 'Group' or 'Subhalo'.\n        as_dict: If True, a dictionary is returned, otherwise as\n          h5py.Group object.\n\n    Returns:\n        (dict): The HDF5 group from the group catalog HDF5 file as a dictionary\n\n    Note: Remember to close the HDF5 file afterwards (use &lt;group&gt;._id.close()).\n    \"\"\"\n    f = IllustrisH5File(base_path, snapshot, path_func=get_path)\n    if key in f:\n        if as_dict:\n            group = dict(f[key])\n        else:\n            group = f[key]\n    else:\n        f.close()\n        return None\n    return group\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.load_halos","title":"load_halos","text":"<pre><code>load_halos(\n    base_path: str, snapshot: int, **kwargs\n) -&gt; dict | NDArray\n</code></pre> <p>Load all halo information from the entire group catalog for one snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>fields</code> <p>Fields to be loaded for the corresponding group, e.g. ['GroupPos', 'GroupMass'] or 'SubhaloGasMetalFractions'.</p> required <code>as_float32</code> <p>Load float64 data types as float32 (to save memory).</p> required <code>as_array</code> <p>Return a numpy array instead of a dictionary; takes effect only if a single field was requested.</p> required <code>with_pbar</code> <p>If True, a progress bar will show the current status.</p> required <code>**kwargs</code> <p>Additonal keywords for <code>load_catalog</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | numpy.ndarray</code> <p>A dictionary of the loaded data</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def load_halos(base_path: str, snapshot: int, **kwargs) -&gt; dict | NDArray:\n    \"\"\"Load all halo information from the entire group catalog for one snapshot.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        fields: Fields to be loaded for the corresponding group,\n          e.g. ['GroupPos', 'GroupMass'] or 'SubhaloGasMetalFractions'.\n        as_float32: Load float64 data types as float32 (to save memory).\n        as_array: Return a numpy array instead of a dictionary; takes\n          effect only if a single field was requested.\n        with_pbar: If True, a progress bar will show the current status.\n        **kwargs: Additonal keywords for `load_catalog`\n\n    Returns:\n        (dict | numpy.ndarray): A dictionary of the loaded data\n    \"\"\"\n    return load_catalog(base_path, snapshot, \"Group\", \"groups\", **kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.load_header","title":"load_header","text":"<pre><code>load_header(\n    base_path: str, snapshot: int, as_dict: bool = True\n) -&gt; dict | h5py.Group\n</code></pre> <p>Load the header of a group catalog.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>as_dict</code> <code>bool</code> <p>If True, a dictionary is returned, otherwise as h5py.Group object.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>The header of the group catalog HDF5 file as a dictionary</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def load_header(\n    base_path: str,\n    snapshot: int,\n    as_dict: bool = True,\n) -&gt; dict | h5py.Group:\n    \"\"\"Load the header of a group catalog.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        as_dict: If True, a dictionary is returned, otherwise as\n          h5py.Group object.\n\n    Returns:\n        (dict): The header of the group catalog HDF5 file as a dictionary\n    \"\"\"\n    with IllustrisH5File(base_path, snapshot, path_func=get_path) as f:\n        if as_dict:\n            header = dict(f[\"Header\"].attrs.items())\n        else:\n            header = f[\"Header\"]\n    return header\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.load_single","title":"load_single","text":"<pre><code>load_single(\n    base_path, snapshot, halo_id=-1, subhalo_id=-1\n) -&gt; dict\n</code></pre> <p>Fetch the complete group catalog information for a single halo or subhalo.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <p>Snapshot ID {0-99}.</p> required <code>halo_id</code> <p>Group ID, i.e. halo ID value from the FOF catalog.</p> <code>-1</code> <code>subhalo_id</code> <p>Group ID, i.e. subhalo ID value from the FOF catalog.</p> <code>-1</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the loaded data</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def load_single(base_path, snapshot, halo_id=-1, subhalo_id=-1) -&gt; dict:\n    \"\"\"Fetch the complete group catalog information for a single halo or subhalo.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        halo_id: Group ID, i.e. halo ID value from the FOF catalog.\n        subhalo_id: Group ID, i.e. subhalo ID value from the FOF catalog.\n\n    Returns:\n        (dict): A dictionary of the loaded data\n    \"\"\"\n    if (halo_id &lt; 0 and subhalo_id &lt; 0) or (halo_id &gt;= 0 and subhalo_id &gt;= 0):\n        raise ValueError(\"Must specify either halo_id or subhalo_id (not both).\")\n    key = \"Subhalo\" if subhalo_id &gt;= 0 else \"Group\"\n    group_id = subhalo_id if subhalo_id &gt;= 0 else halo_id\n    # old or new format\n    if \"fof_subhalo\" in get_path(base_path, snapshot):\n        # use separate 'offsets_nnn.hdf5' files\n        with IllustrisH5File(base_path, snapshot, path_func=get_offset_path) as f:\n            offsets = f[\"FileOffsets/\" + key][()]\n    else:\n        # use header of group catalog\n        with IllustrisH5File(base_path, snapshot, path_func=get_path) as f:\n            offsets = f[\"Header\"].attrs[\"FileOffsets_\" + key]\n    offsets = group_id - offsets\n    file_id = np.max(np.where(offsets &gt;= 0))\n    group_offset = offsets[file_id]\n    # load halo/subhalo fields into a dict\n    data = {}\n    with IllustrisH5File(base_path, snapshot, file_id, path_func=get_path) as f:\n        for field in f[key].keys():\n            data[field] = f[key][field][group_offset]\n    return data\n</code></pre>"},{"location":"reference/skais_mapper/illustris/groupcat/#skais_mapper.illustris.groupcat.load_subhalos","title":"load_subhalos","text":"<pre><code>load_subhalos(\n    base_path: str, snapshot: int, **kwargs\n) -&gt; dict | NDArray\n</code></pre> <p>Load all subhalo information from the entire group catalog for one snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>**kwargs</code> <p>Additional keywords such as fields: Fields to be loaded for the corresponding group, e.g. ['GroupPos', 'GroupMass'] or 'SubhaloGasMetalFractions'. as_float32: Load float64 data types as float32 (to save memory). as_array: Return a numpy array instead of a dictionary; takes effect only if a single field was requested. with_pbar: If True, a progress bar will show the current status.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | numpy.ndarray</code> <p>A dictionary of the loaded data</p> Source code in <code>skais_mapper/illustris/groupcat.py</code> <pre><code>def load_subhalos(base_path: str, snapshot: int, **kwargs) -&gt; dict | NDArray:\n    \"\"\"Load all subhalo information from the entire group catalog for one snapshot.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        **kwargs: Additional keywords such as\n          fields: Fields to be loaded for the corresponding group,\n            e.g. ['GroupPos', 'GroupMass'] or 'SubhaloGasMetalFractions'.\n          as_float32: Load float64 data types as float32 (to save memory).\n          as_array: Return a numpy array instead of a dictionary; takes\n            effect only if a single field was requested.\n          with_pbar: If True, a progress bar will show the current status.\n\n    Returns:\n        (dict | numpy.ndarray): A dictionary of the loaded data\n    \"\"\"\n    return load_catalog(base_path, snapshot, \"Subhalo\", \"subgroups\", **kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/","title":"skais_mapper.illustris.snapshots","text":""},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots","title":"skais_mapper.illustris.snapshots","text":"<p>Illustris simulation snapshot file i/o.</p> <p>Adapted from: https://github.com/illustristng/illustris_python</p> <p>Functions:</p> Name Description <code>find_group_in_partitions</code> <p>Find the first occurrence of a group name in a set of HDF5 file partitions.</p> <code>get_path</code> <p>Get absolute path to a snapshot HDF5 file (modify as needed).</p> <code>load_halo</code> <p>Load all particles of a type for a specific halo (optionally restricted to a subset fields).</p> <code>load_header</code> <p>Load the header of a snapshot.</p> <code>load_snapshot</code> <p>Load a subset of fields of a snapshot for all particles of a given type.</p> <code>load_subhalo</code> <p>Load all particles of a type for a specific subhalo (optionally limited to a subset fields).</p> <code>particle_numbers</code> <p>Calculate the number of particles of all types given a snapshot header.</p> <code>snapshot_offsets</code> <p>Compute offsets within snapshot for a particular HDF5 group/subgroup.</p>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.find_group_in_partitions","title":"find_group_in_partitions","text":"<pre><code>find_group_in_partitions(\n    base_path: str, snapshot: int, key: str\n) -&gt; h5py.File\n</code></pre> <p>Find the first occurrence of a group name in a set of HDF5 file partitions.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>key</code> <code>str</code> <p>The group name to find in the partitions, e.g. PartType5</p> required <p>Returns:</p> Type Description <code>h5py.File</code> <p>A HDF5 file partition containing the group name.</p> <p>Note: Remember to close the HDF5 file afterwards.</p> Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def find_group_in_partitions(base_path: str, snapshot: int, key: str) -&gt; h5py.File:\n    \"\"\"Find the first occurrence of a group name in a set of HDF5 file partitions.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        key: The group name to find in the partitions, e.g. PartType5\n\n    Returns:\n        (h5py.File): A HDF5 file partition containing the group name.\n\n    Note: Remember to close the HDF5 file afterwards.\n    \"\"\"\n    partition = 0\n    while True:\n        f = IllustrisH5File(base_path, snapshot, partition)\n        if not f.exists:\n            return None\n        if key in f:\n            break\n        partition += 1\n        f.close()\n    return f\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.get_path","title":"get_path","text":"<pre><code>get_path(\n    base_path: str, snapshot: int, partition: int = 0\n) -&gt; str\n</code></pre> <p>Get absolute path to a snapshot HDF5 file (modify as needed).</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>partition</code> <code>int</code> <p>Subfile partition ID {0-600+}.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>Absolute path to a snapshot HDF5 file</p> Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def get_path(base_path: str, snapshot: int, partition: int = 0) -&gt; str:\n    \"\"\"Get absolute path to a snapshot HDF5 file (modify as needed).\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        partition: Subfile partition ID {0-600+}.\n\n    Returns:\n        (str): Absolute path to a snapshot HDF5 file\n    \"\"\"\n    snap_dir = os.path.join(base_path, f\"snapshots/{snapshot:03d}\")\n    filepath = os.path.join(snap_dir, f\"snap_{snapshot:03d}.{partition:d}.hdf5\")\n    filepath_alt = filepath.replace(\"snap_\", \"snapshot_\")\n    if os.path.isfile(filepath):\n        return filepath\n    return filepath_alt\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.load_halo","title":"load_halo","text":"<pre><code>load_halo(\n    base_path: str,\n    snapshot: int,\n    halo_id: int,\n    p_type: str,\n    **kwargs,\n) -&gt; dict | NDArray\n</code></pre> <p>Load all particles of a type for a specific halo (optionally restricted to a subset fields).</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>halo_id</code> <code>int</code> <p>Group ID, i.e. halo ID value from the FOF catalog</p> required <code>p_type</code> <code>str</code> <p>Particle type description string; e.g. 'gas', 'dm', 'stars', '1', '2', etc.</p> required <code>kwargs</code> <p>fields: Fields to be loaded for the corresponding ptype,     e.g. ['Coordinates', 'Masses'] or 'NeutralHydrogenAbundance'. mdi: Multi-dimensional indices for fields; must be the     same length as fields. E.g. fields = ['Coordinates', 'Masses'] and     mdi = [1, None] returns a 1D array of y-coordinates and masses instead     of a 3D array of coordinates with masses. as_float32: Load float64 data types as float32 (to save memory). as_array: return a numpy array instead of a dictionary; takes     effect only if a single field was requested.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | numpy.ndarray</code> <p>A dictionary of the loaded data.</p> Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def load_halo(base_path: str, snapshot: int, halo_id: int, p_type: str, **kwargs) -&gt; dict | NDArray:\n    \"\"\"Load all particles of a type for a specific halo (optionally restricted to a subset fields).\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        halo_id: Group ID, i.e. halo ID value from the FOF catalog\n        p_type: Particle type description string;\n          e.g. 'gas', 'dm', 'stars', '1', '2', etc.\n        kwargs:\n            fields: Fields to be loaded for the corresponding ptype,\n                e.g. ['Coordinates', 'Masses'] or 'NeutralHydrogenAbundance'.\n            mdi: Multi-dimensional indices for fields; must be the\n                same length as fields. E.g. fields = ['Coordinates', 'Masses'] and\n                mdi = [1, None] returns a 1D array of y-coordinates and masses instead\n                of a 3D array of coordinates with masses.\n            as_float32: Load float64 data types as float32 (to save memory).\n            as_array: return a numpy array instead of a dictionary; takes\n                effect only if a single field was requested.\n\n    Returns:\n        (dict | numpy.ndarray): A dictionary of the loaded data.\n    \"\"\"\n    subset = snapshot_offsets(base_path, snapshot, halo_id, \"Group\")\n    return load_snapshot(base_path, snapshot, p_type, subset=subset, **kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.load_header","title":"load_header","text":"<pre><code>load_header(\n    base_path: str, snapshot: int, as_dict: bool = True\n) -&gt; dict | h5py.Group\n</code></pre> <p>Load the header of a snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>as_dict</code> <code>bool</code> <p>If True, a dictionary is returned, otherwise as h5py.Group object.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>The header of the snapshot HDF5 file as a dictionary</p> Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def load_header(\n    base_path: str,\n    snapshot: int,\n    as_dict: bool = True,\n) -&gt; dict | h5py.Group:\n    \"\"\"Load the header of a snapshot.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        as_dict: If True, a dictionary is returned, otherwise as h5py.Group object.\n\n    Returns:\n        (dict): The header of the snapshot HDF5 file as a dictionary\n    \"\"\"\n    with IllustrisH5File(base_path, snapshot) as f:\n        if as_dict:\n            header = dict(f[\"Header\"].attrs.items())\n        else:\n            header = f[\"Header\"]\n    return header\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.load_snapshot","title":"load_snapshot","text":"<pre><code>load_snapshot(\n    base_path: str,\n    snapshot: int,\n    ptype: str,\n    fields: list[str] | str | None = None,\n    mdi: list[int] | int | None = None,\n    subset: dict | None = None,\n    as_float32: bool = False,\n    as_array: bool = True,\n    with_pbar: bool = True,\n) -&gt; dict | NDArray | None\n</code></pre> <p>Load a subset of fields of a snapshot for all particles of a given type.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>ptype</code> <code>str</code> <p>Particle type description string; e.g. 'gas', 'dm', 'stars', '1', '2', etc.</p> required <code>fields</code> <code>list[str] | str | None</code> <p>Fields to be loaded for the corresponding ptype, e.g. ['Coordinates', 'Masses'] or 'NeutralHydrogenAbundance'.</p> <code>None</code> <code>mdi</code> <code>list[int] | int | None</code> <p>Multi-dimensional indices for fields; must be the same length as fields. E.g. fields = ['Coordinates', 'Masses'] and mdi = [1, None] returns a 1D array of y-coordinates and masses instead of a 3D array of coordinates with masses.</p> <code>None</code> <code>subset</code> <code>dict | None</code> <p>Subset specification dictionary; see return of . <code>None</code> <code>as_float32</code> <code>bool</code> <p>Load float64 data types as float32 (to save memory).</p> <code>False</code> <code>as_array</code> <code>bool</code> <p>return a numpy array instead of a dictionary; takes effect only if a single field was requested.</p> <code>True</code> <code>with_pbar</code> <code>bool</code> <p>If True, a progress bar will show the current status.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict | numpy.ndarray</code> <p>A dictionary of the loaded data</p> Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def load_snapshot(\n    base_path: str,\n    snapshot: int,\n    ptype: str,\n    fields: list[str] | str | None = None,\n    mdi: list[int] | int | None = None,\n    subset: dict | None = None,\n    as_float32: bool = False,\n    as_array: bool = True,\n    with_pbar: bool = True,\n) -&gt; dict | NDArray | None:\n    \"\"\"Load a subset of fields of a snapshot for all particles of a given type.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        ptype: Particle type description string;\n            e.g. 'gas', 'dm', 'stars', '1', '2', etc.\n        fields: Fields to be loaded for the corresponding ptype,\n            e.g. ['Coordinates', 'Masses'] or 'NeutralHydrogenAbundance'.\n        mdi: Multi-dimensional indices for fields; must be the\n            same length as fields. E.g. fields = ['Coordinates', 'Masses'] and\n            mdi = [1, None] returns a 1D array of y-coordinates and masses instead\n            of a 3D array of coordinates with masses.\n        subset: Subset specification dictionary;\n            see return of &lt;skais_mapper.illustris.snapshots.snapshot_offsets&gt;.\n        as_float32: Load float64 data types as float32 (to save memory).\n        as_array: return a numpy array instead of a dictionary; takes\n            effect only if a single field was requested.\n        with_pbar: If True, a progress bar will show the current status.\n\n    Returns:\n        (dict | numpy.ndarray): A dictionary of the loaded data\n    \"\"\"\n    data = {}\n    # process arguments\n    p_idx = pidx_from_ptype(ptype)\n    key = \"PartType\" + str(p_idx)\n    if fields is None:\n        fields = []\n    elif isinstance(fields, str | bytes):\n        fields = [fields]\n    if mdi is None:\n        mdi = []\n    elif isinstance(mdi, int):\n        mdi = [mdi]\n    # load header from first partition\n    IllustrisH5File.path_func = get_path\n    header = load_header(base_path, snapshot, as_dict=True)\n    p_numbers = particle_numbers(header)\n    # decide global read size, starting partition number and offset\n    if subset:\n        offset_ptype = subset[\"offsetType\"][p_idx] - subset[\"snapOffsets\"][p_idx, :]\n        file_id = np.max(np.where(offset_ptype &gt;= 0))\n        file_off = offset_ptype[file_id]\n        p_n = subset[\"lenType\"][p_idx]\n    else:\n        file_id = 0\n        file_off = 0\n        p_n = p_numbers[p_idx]\n    # save total count of requested particle type\n    data[\"count\"] = p_n\n    if not p_n:  # if any, otherwise we're done here\n        return data\n    # find the first partition with this particle type\n    f = find_group_in_partitions(base_path, snapshot, key)\n    if not f:\n        return None\n    # if fields not specified, load everything\n    if not fields:\n        fields = list(f[key].keys())\n    # loop over all requested fields\n    for i, field in enumerate(fields):\n        if field not in f[key].keys():\n            raise KeyError(f\"Particle type [{p_idx}] does not have field [{field}]\")\n        # replace local length with global\n        shape = list(f[key][field].shape)\n        shape[0] = p_n\n        # or use multi-dimensional index slice\n        if mdi and mdi[i] is not None:\n            if len(shape) != 2:\n                raise IndexError(\"Read error: mdi requested on non-2D field [{field}]\")\n            shape = [shape[0]]\n        # allocate data arrays\n        dtype = f[key][field].dtype\n        if dtype == np.float64 and as_float32:\n            dtype = np.float32\n        data[field] = np.zeros(shape, dtype=dtype)\n    f.close()\n    # loop over partitions\n    arr_offset = 0\n    p_n_all = p_n\n    n_files = header[\"NumFilesPerSnapshot\"] - file_id\n    if with_pbar:\n        print(f\"Reading relevant files [{n_files}]...\")\n        partition_iterator = trange(file_id, header[\"NumFilesPerSnapshot\"])\n    else:\n        partition_iterator = range(file_id, header[\"NumFilesPerSnapshot\"])\n    for file_id in partition_iterator:\n        f = IllustrisH5File(base_path, snapshot, file_id)\n        # if no particles of requested type in partition, update and continue\n        if key not in f:\n            f.close()\n            file_off = 0\n            continue\n        # set local read length for this partition\n        p_n_file = f[\"Header\"].attrs[\"NumPart_ThisFile\"][p_idx]\n        p_n_local = p_n\n        # truncate local size\n        if file_off + p_n_local &gt; p_n_file:\n            p_n_local = p_n_file - file_off\n        # fetch all requested fields from partition\n        for i, field in enumerate(fields):\n            if mdi and mdi[i] is not None:\n                data[field][arr_offset : arr_offset + p_n_local] = f[key][field][\n                    file_off : file_off + p_n_local, mdi[i]\n                ]\n            else:\n                data[field][arr_offset : arr_offset + p_n_local] = f[key][field][\n                    file_off : file_off + p_n_local\n                ]\n        # reset for the next partition\n        arr_offset += p_n_local\n        p_n -= p_n_local\n        file_off = 0\n        f.close()\n        if p_n &lt;= 0:\n            partition_iterator.update(header[\"NumFilesPerSnapshot\"] - file_id)\n            partition_iterator.refresh()\n            partition_iterator.close()\n            break\n    # verify we read the correct number\n    if p_n_all != arr_offset:\n        raise RuntimeError(f\"Read [{arr_offset}] particles, but was expecting [{p_n_all}]\")\n    if as_array and len(fields) == 1:\n        return data[fields[0]]\n    return data\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.load_subhalo","title":"load_subhalo","text":"<pre><code>load_subhalo(\n    base_path: str,\n    snapshot: int,\n    subhalo_id: int,\n    p_type: str,\n    **kwargs,\n) -&gt; dict | NDArray\n</code></pre> <p>Load all particles of a type for a specific subhalo (optionally limited to a subset fields).</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>subhalo_id</code> <code>int</code> <p>Group ID, i.e. subhalo ID value from the FOF catalog</p> required <code>p_type</code> <code>str</code> <p>Particle type description string; e.g. 'gas', 'dm', 'stars', '1', '2', etc.</p> required <code>kwargs</code> <p>fields: Fields to be loaded for the corresponding ptype,     e.g. ['Coordinates', 'Masses'] or 'NeutralHydrogenAbundance'. mdi: Multi-dimensional indices for fields; must be the     same length as fields. E.g. fields = ['Coordinates', 'Masses'] and     mdi = [1, None] returns a 1D array of y-coordinates and masses instead     of a 3D array of coordinates with masses. as_float32 (bool): Load float64 data types as float32 (to save memory). as_array (bool): return a numpy array instead of a dictionary; takes   effect only if a single field was requested.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | numpy.ndarray</code> <p>A dictionary of the loaded data.</p> Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def load_subhalo(\n    base_path: str, snapshot: int, subhalo_id: int, p_type: str, **kwargs\n) -&gt; dict | NDArray:\n    \"\"\"Load all particles of a type for a specific subhalo (optionally limited to a subset fields).\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        subhalo_id: Group ID, i.e. subhalo ID value from the FOF catalog\n        p_type: Particle type description string;\n            e.g. 'gas', 'dm', 'stars', '1', '2', etc.\n        kwargs:\n            fields: Fields to be loaded for the corresponding ptype,\n                e.g. ['Coordinates', 'Masses'] or 'NeutralHydrogenAbundance'.\n            mdi: Multi-dimensional indices for fields; must be the\n                same length as fields. E.g. fields = ['Coordinates', 'Masses'] and\n                mdi = [1, None] returns a 1D array of y-coordinates and masses instead\n                of a 3D array of coordinates with masses.\n            as_float32 (bool): Load float64 data types as float32 (to save memory).\n            as_array (bool): return a numpy array instead of a dictionary; takes\n              effect only if a single field was requested.\n\n    Returns:\n        (dict | numpy.ndarray): A dictionary of the loaded data.\n    \"\"\"\n    subset = snapshot_offsets(base_path, snapshot, subhalo_id, \"Subhalo\")\n    return load_snapshot(base_path, snapshot, p_type, subset=subset, **kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.particle_numbers","title":"particle_numbers","text":"<pre><code>particle_numbers(\n    header: h5py.Group, n_types: int = 6\n) -&gt; NDArray[np.int64]\n</code></pre> <p>Calculate the number of particles of all types given a snapshot header.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>h5py.Group</code> <p>Header of the snapshot HDF5 file.</p> required <code>n_types</code> <code>int</code> <p>Number of particle types (almost always 6).</p> <code>6</code> <p>Returns:</p> Type Description <code>np.ndarray[np.int64]</code> <p>Number of particles for each type.</p> Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def particle_numbers(header: h5py.Group, n_types: int = 6) -&gt; NDArray[np.int64]:\n    \"\"\"Calculate the number of particles of all types given a snapshot header.\n\n    Args:\n        header: Header of the snapshot HDF5 file.\n        n_types: Number of particle types (almost always 6).\n\n    Returns:\n        (np.ndarray[np.int64]): Number of particles for each type.\n    \"\"\"\n    if \"NumPart_Total_HighWord\" not in header:\n        return header[\"NumPart_Total\"]  # new u64 convention\n    n_part = np.zeros(n_types, dtype=np.int64)\n    for j in range(n_types):\n        n_part[j] = header[\"NumPart_Total\"][j] | (header[\"NumPart_Total_HighWord\"][j] &lt;&lt; 32)\n    return n_part\n</code></pre>"},{"location":"reference/skais_mapper/illustris/snapshots/#skais_mapper.illustris.snapshots.snapshot_offsets","title":"snapshot_offsets","text":"<pre><code>snapshot_offsets(\n    base_path: str, snapshot: int, group_id: int, gtype: str\n) -&gt; dict\n</code></pre> <p>Compute offsets within snapshot for a particular HDF5 group/subgroup.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>group_id</code> <code>int</code> <p>Group ID, i.e. a halo or subhalo ID value from the FOF catalog</p> required <code>gtype</code> <code>str</code> <p>Group type, i.e. 'Group' or 'Subhalo'.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Subset of snapshot data to be loaded with . Source code in <code>skais_mapper/illustris/snapshots.py</code> <pre><code>def snapshot_offsets(\n    base_path: str,\n    snapshot: int,\n    group_id: int,\n    gtype: str,\n) -&gt; dict:\n    \"\"\"Compute offsets within snapshot for a particular HDF5 group/subgroup.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        group_id: Group ID, i.e. a halo or subhalo ID value from the FOF catalog\n        gtype: Group type, i.e. 'Group' or 'Subhalo'.\n\n    Returns:\n        (dict): Subset of snapshot data to be loaded with &lt;load_snapshot&gt;.\n    \"\"\"\n    subset = {}\n    # old/new format\n    IllustrisH5File.path_func = get_cat_path\n    if \"fof_subhalo\" in get_cat_path(base_path, snapshot):\n        # use separate 'offsets_nnn.hdf5' files\n        with IllustrisH5File(base_path, snapshot, path_func=get_offset_path) as f:\n            file_offsets = f[\"FileOffsets/\" + gtype][()]\n            # for consistency\n            subset[\"snapOffsets\"] = np.transpose(f[\"FileOffsets/SnapByType\"][()])\n    else:\n        # load groupcat partition offsets from header of the first file\n        with IllustrisH5File(base_path, snapshot) as f:\n            file_offsets = f[\"Header\"].attrs[\"FileOffsets_\" + gtype]\n            subset[\"snapOffsets\"] = f[\"Header\"].attrs[\"FileOffsets_Snap\"]\n    # get target groups partition which contains this group_id\n    file_offsets = int(group_id) - file_offsets\n    file_id = np.max(np.where(file_offsets &gt;= 0))\n    group_offset = file_offsets[file_id]\n    # load the length (by type) of this group/subgroup from the group catalog\n    with IllustrisH5File(base_path, snapshot, file_id) as f:\n        subset[\"lenType\"] = f[gtype][gtype + \"LenType\"][group_offset, :]\n    # old/new format: load the offset (by type) of this group in the snapshot\n    if \"fof_subhalo\" in get_cat_path(base_path, snapshot):\n        with IllustrisH5File(base_path, snapshot, path_func=get_offset_path) as f:\n            subset[\"offsetType\"] = f[gtype + \"/SnapByType\"][group_id, :]\n    else:\n        with IllustrisH5File(base_path, snapshot, file_id) as f:\n            subset[\"offsetType\"] = f[\"Offsets\"][gtype + \"_SnapByType\"][group_offset, :]\n    return subset\n</code></pre>"},{"location":"reference/skais_mapper/illustris/util/","title":"skais_mapper.illustris.util","text":""},{"location":"reference/skais_mapper/illustris/util/#skais_mapper.illustris.util","title":"skais_mapper.illustris.util","text":"<p>Illustris simulation snapshot utilities.</p> <p>Adapted from: https://github.com/illustristng/illustris_python</p> <p>Classes:</p> Name Description <code>IllustrisH5File</code> <p>Represents an Illustris HDF5 file. Wrapper for the  class. <p>Functions:</p> Name Description <code>pidx_from_ptype</code> <p>Mapping common names to indices of particle types.</p> <code>ptype_from_pidx</code> <p>Mapping indices to names of particle types.</p>"},{"location":"reference/skais_mapper/illustris/util/#skais_mapper.illustris.util.IllustrisH5File","title":"IllustrisH5File","text":"<pre><code>IllustrisH5File(\n    base_path: str | Path,\n    snapshot: int,\n    partition: int = 0,\n    path_func: Callable | None = None,\n    mode: str = \"r\",\n    driver: str | None = None,\n    cache_size: int | float | str = \"2G\",\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>h5py.File</code></p> <p>Represents an Illustris HDF5 file. Wrapper for the  class. <p>Initialize a IllustrisH5File instance.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str | Path</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>partition</code> <code>int</code> <p>Subfile partition ID {0-600+}.</p> <code>0</code> <code>path_func</code> <code>Callable | None</code> <p>A function fetching the filename of the HDF5 file. The function should accept , ,  as arguments. <code>None</code> <code>mode</code> <code>str</code> <p>'r'          Readonly, file must exist (default) 'r+'         Read/write, file must exist 'w'          Create file, truncate if exists 'w-' or 'x'  Create file, fail if exists 'a'          Read/write if exists, create otherwise.</p> <code>'r'</code> <code>driver</code> <code>str | None</code> <p>Name of the driver to use; valid values are None (default), 'core', 'sec2', 'direct', 'stdio', 'mpio', 'ros3'.</p> <code>None</code> <code>cache_size</code> <code>int | float | str</code> <p>Chunk cache size in bytes or passed as string.</p> <code>'2G'</code> <code>**kwargs</code> <p>More keyword arguments</p> <code>{}</code> Source code in <code>skais_mapper/illustris/util.py</code> <pre><code>def __init__(\n    self,\n    base_path: str | Path,\n    snapshot: int,\n    partition: int = 0,\n    path_func: Callable | None = None,\n    mode: str = \"r\",\n    driver: str | None = None,\n    cache_size: int | float | str = \"2G\",\n    **kwargs,\n):\n    \"\"\"Initialize a IllustrisH5File instance.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        partition: Subfile partition ID {0-600+}.\n        path_func:\n            A function fetching the filename of the HDF5 file. The function\n            should accept &lt;base_path&gt;, &lt;snapshot&gt;, &lt;partition&gt; as arguments.\n        mode:\n            'r'          Readonly, file must exist (default)\n            'r+'         Read/write, file must exist\n            'w'          Create file, truncate if exists\n            'w-' or 'x'  Create file, fail if exists\n            'a'          Read/write if exists, create otherwise.\n        driver: Name of the driver to use; valid values are\n            None (default), 'core', 'sec2', 'direct', 'stdio', 'mpio', 'ros3'.\n        cache_size: Chunk cache size in bytes or passed as string.\n        **kwargs: More keyword arguments\n    \"\"\"\n    self.exists = True\n    self.chunk_cache_size = nbytes(cache_size)\n    kwargs.setdefault(\"rdcc_nbytes\", int(self.chunk_cache_size))\n    kwargs.setdefault(\"rdcc_w0\", 1.0)\n    if os.path.exists(self.filename):\n        super().__init__(self.filename, mode=mode, driver=driver, **kwargs)\n    else:\n        self.exists = False\n</code></pre>"},{"location":"reference/skais_mapper/illustris/util/#skais_mapper.illustris.util.pidx_from_ptype","title":"pidx_from_ptype","text":"<pre><code>pidx_from_ptype(ptype: int | str) -&gt; int\n</code></pre> <p>Mapping common names to indices of particle types.</p> <p>Parameters:</p> Name Type Description Default <code>ptype</code> <code>int | str</code> <p>particle type description string</p> required <p>Returns:</p> Type Description <code>int</code> <p>(int) particle type index 0 -&gt; gas particles 1 -&gt; dark-matter particles 2 -&gt; lowres dark-matter / stellar disc particles (in zoom simulations) 3 -&gt; tracer / stellar buldge particles 4 -&gt; star / wind / stellar particles 5 -&gt; blackhole / sink particles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name doesn't match any particle type.</p> Source code in <code>skais_mapper/illustris/util.py</code> <pre><code>def pidx_from_ptype(ptype: int | str) -&gt; int:\n    \"\"\"Mapping common names to indices of particle types.\n\n    Args:\n        ptype: particle type description string\n\n    Returns:\n        (int) particle type index\n          0 -&gt; gas particles\n          1 -&gt; dark-matter particles\n          2 -&gt; lowres dark-matter / stellar disc particles (in zoom simulations)\n          3 -&gt; tracer / stellar buldge particles\n          4 -&gt; star / wind / stellar particles\n          5 -&gt; blackhole / sink particles\n\n    Raises:\n        (ValueError): If the name doesn't match any particle type.\n    \"\"\"\n    if str(ptype).isdigit():\n        return int(ptype)\n    if str(ptype).lower() in [\"gas\", \"cells\"]:\n        return 0\n    if str(ptype).lower() in [\"dm\", \"darkmatter\"]:\n        return 1\n    if str(ptype).lower() in [\"dmlowres\"]:\n        return 2  # only zoom simulations, not present in full periodic boxes\n    if str(ptype).lower() in [\"tracer\", \"tracers\", \"tracermc\", \"trmc\"]:\n        return 3\n    if str(ptype).lower() in [\"star\", \"stars\", \"stellar\"]:\n        return 4  # only those with GFM_StellarFormationTime &gt; 0\n    if str(ptype).lower() in [\"wind\"]:\n        return 4  # only those with GFM_StellarFormationTime &lt; 0\n    if str(ptype).lower() in [\"bh\", \"bhs\", \"blackhole\", \"blackholes\"]:\n        return 5\n    raise ValueError(f\"Unknown particle type name {ptype}.\")\n</code></pre>"},{"location":"reference/skais_mapper/illustris/util/#skais_mapper.illustris.util.ptype_from_pidx","title":"ptype_from_pidx","text":"<pre><code>ptype_from_pidx(pidx: int | str) -&gt; str\n</code></pre> <p>Mapping indices to names of particle types.</p> <p>Parameters:</p> Name Type Description Default <code>pidx</code> <code>int | str</code> <p>particle type index</p> required <p>Returns:</p> Type Description <code>str</code> <p>(int) particle type index gas particles -&gt; 0 dark-matter particles -&gt; 1 lowres dark-matter / stellar disc particles (in zoom simulations) -&gt; 2 tracer / stellar buldge particles -&gt; 3 star / wind / stellar particles -&gt; 4 blackhole / sink particles -&gt; 5</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the index is not</p> Source code in <code>skais_mapper/illustris/util.py</code> <pre><code>def ptype_from_pidx(pidx: int | str) -&gt; str:\n    \"\"\"Mapping indices to names of particle types.\n\n    Args:\n        pidx: particle type index\n\n    Returns:\n        (int) particle type index\n          gas particles -&gt; 0\n          dark-matter particles -&gt; 1\n          lowres dark-matter / stellar disc particles (in zoom simulations) -&gt; 2\n          tracer / stellar buldge particles -&gt; 3\n          star / wind / stellar particles -&gt; 4\n          blackhole / sink particles -&gt; 5\n\n    Raises:\n        (ValueError): If the index is not\n    \"\"\"\n    if isinstance(pidx, str):\n        return pidx\n    if pidx == 0:\n        return \"gas\"\n    if pidx == 1:\n        return \"dm\"\n    if pidx == 2:\n        return \"dmlowres\"  # only zoom simulations, not present in full periodic boxes\n    if pidx == 3:\n        return \"tracer\"\n    if pidx == 4:\n        return \"star\"  # only those with GFM_StellarFormationTime &gt; 0\n    if pidx == 5:\n        return \"bh\"\n    raise ValueError(f\"Unknown particle type name {pidx}.\")\n</code></pre>"},{"location":"reference/skais_mapper/plotting/","title":"skais_mapper.plotting","text":""},{"location":"reference/skais_mapper/plotting/#skais_mapper.plotting","title":"skais_mapper.plotting","text":"<p>Plotting routines for maps and images.</p> <p>Functions:</p> Name Description <code>plot_image</code> <p>Plot map from an array, tensor, or batch(es).</p> <code>plot_image_array</code> <p>Plot map from an array or batch(es).</p> <code>plot_image_from_batch</code> <p>Plot map from an array/tensor batch (optionally including metadata).</p> <code>plot_image_quantity</code> <p>Plot map from an astropy.units.Quantity array or batch(es).</p> <code>plot_image_tensor</code> <p>Plot map from a tensor, or batch(es).</p>"},{"location":"reference/skais_mapper/plotting/#skais_mapper.plotting.plot_image","title":"plot_image","text":"<pre><code>plot_image(\n    data: Any,\n    batch_idx: int | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n)\n</code></pre> <p>Plot map from an array, tensor, or batch(es).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array(s) of a map (or maps).</p> required <code>batch_idx</code> <code>int | None</code> <p>If not <code>None</code>, data is a single or multiple batches of images.</p> <code>None</code> <code>info</code> <p>Supplementary information about the data.</p> required <code>extent</code> <code>Sequence[float] | None</code> <p>Extent of the map in physical units.</p> <code>None</code> <code>colormap</code> <code>None</code> <p>Name of the colormap to use for plotting.</p> <code>None</code> <code>colorbar</code> <code>bool</code> <p>If <code>True</code>, include the colorbar in the plot.</p> <code>False</code> <code>colorbar_label</code> <code>str | None</code> <p>Label of the colorbar (if enabled).</p> <code>None</code> <code>xlabel</code> <code>str | None</code> <p>Label of the x-axis.</p> <code>None</code> <code>ylabel</code> <code>str | None</code> <p>Label of the y-axis.</p> <code>None</code> <code>savefig</code> <code>bool</code> <p>If <code>True</code>, save the plot to file.</p> <code>False</code> <code>path</code> <code>str | Path | None</code> <p>Filename or filepath where the figure is saved.</p> <code>None</code> <code>show</code> <code>bool</code> <p>If <code>True</code>, show the plot.</p> <code>False</code> <code>close</code> <code>bool</code> <p>If <code>True</code>, closes the figure.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Print results to stdout.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments for <code>matplotlib.pyplot.imshow</code>.</p> <code>{}</code> Source code in <code>skais_mapper/plotting.py</code> <pre><code>@singledispatch\n@alias_kw(\"colormap\", \"cmap\")\n@alias_kw(\"colorbar\", \"cbar\")\n@alias_kw(\"colorbar_label\", \"cbar_label\")\ndef plot_image(\n    data: Any,\n    batch_idx: int | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Plot map from an array, tensor, or batch(es).\n\n    Args:\n        data: Array(s) of a map (or maps).\n        batch_idx: If not `None`, data is a single or multiple batches of images.\n        info: Supplementary information about the data.\n        extent: Extent of the map in physical units.\n        colormap: Name of the colormap to use for plotting.\n        colorbar: If `True`, include the colorbar in the plot.\n        colorbar_label: Label of the colorbar (if enabled).\n        xlabel: Label of the x-axis.\n        ylabel: Label of the y-axis.\n        savefig: If `True`, save the plot to file.\n        path: Filename or filepath where the figure is saved.\n        show: If `True`, show the plot.\n        close: If `True`, closes the figure.\n        verbose: Print results to stdout.\n        kwargs: Additional keyword arguments for `matplotlib.pyplot.imshow`.\n    \"\"\"\n    raise NotImplementedError(f\"Invalid data type {type(data)}.\")\n</code></pre>"},{"location":"reference/skais_mapper/plotting/#skais_mapper.plotting.plot_image_array","title":"plot_image_array","text":"<pre><code>plot_image_array(\n    data: np.ndarray,\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: Colormap | None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n)\n</code></pre> <p>Plot map from an array or batch(es).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray</code> <p>Array(s) of a map (or maps)</p> required <code>batch_idx</code> <code>int | Sequence[int] | None</code> <p>If not <code>None</code>, data is a single or multiple batches of images.</p> <code>None</code> <code>info</code> <p>Supplementary information about the data.</p> required <code>extent</code> <code>Sequence[float] | None</code> <p>Extent of the map in physical units.</p> <code>None</code> <code>colormap</code> <code>Colormap | None</code> <p>Name of the colormap to use for plotting.</p> <code>None</code> <code>colorbar</code> <code>bool</code> <p>If <code>True</code>, include the colorbar in the plot.</p> <code>False</code> <code>colorbar_label</code> <code>str | None</code> <p>Label of the colorbar (if enabled).</p> <code>None</code> <code>xlabel</code> <code>str | None</code> <p>Label of the x-axis.</p> <code>None</code> <code>ylabel</code> <code>str | None</code> <p>Label of the y-axis.</p> <code>None</code> <code>savefig</code> <code>bool</code> <p>If <code>True</code>, save the plot to file.</p> <code>False</code> <code>path</code> <code>str | Path | None</code> <p>Filename or filepath where the figure is saved.</p> <code>None</code> <code>show</code> <code>bool</code> <p>If <code>True</code>, show the plot.</p> <code>False</code> <code>close</code> <code>bool</code> <p>If <code>True</code>, closes the figure.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Print results to stdout.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments for <code>matplotlib.pyplot.imshow</code>.</p> <code>{}</code> Source code in <code>skais_mapper/plotting.py</code> <pre><code>@plot_image.register(np.ndarray)\n@alias_kw(\"colormap\", \"cmap\")\n@alias_kw(\"colorbar\", \"cbar\")\n@alias_kw(\"cbar_label\", \"colorbar_label\")\ndef plot_image_array(\n    data: np.ndarray,\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: Colormap | None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Plot map from an array or batch(es).\n\n    Args:\n        data: Array(s) of a map (or maps)\n        batch_idx: If not `None`, data is a single or multiple batches of images.\n        info: Supplementary information about the data.\n        extent: Extent of the map in physical units.\n        colormap: Name of the colormap to use for plotting.\n        colorbar: If `True`, include the colorbar in the plot.\n        colorbar_label: Label of the colorbar (if enabled).\n        xlabel: Label of the x-axis.\n        ylabel: Label of the y-axis.\n        savefig: If `True`, save the plot to file.\n        path: Filename or filepath where the figure is saved.\n        show: If `True`, show the plot.\n        close: If `True`, closes the figure.\n        verbose: Print results to stdout.\n        kwargs: Additional keyword arguments for `matplotlib.pyplot.imshow`.\n    \"\"\"\n    metadata = kwargs.pop(\"info\", {})\n    data, metadata = _from_batch(data, metadata=metadata, batch_idx=batch_idx)\n    _plot_data(\n        data,\n        metadata,\n        extent=extent,\n        colormap=colormap,\n        colorbar=colorbar,\n        colorbar_label=colorbar_label,\n        xlabel=xlabel,\n        ylabel=ylabel,\n        savefig=savefig,\n        path=path,\n        show=show,\n        close=close,\n        verbose=verbose,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/skais_mapper/plotting/#skais_mapper.plotting.plot_image_from_batch","title":"plot_image_from_batch","text":"<pre><code>plot_image_from_batch(\n    data: Sequence[Tensor | np.ndarray | dict],\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n)\n</code></pre> <p>Plot map from an array/tensor batch (optionally including metadata).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[Tensor | np.ndarray | dict]</code> <p>Array(s) of a map (or maps)</p> required <code>batch_idx</code> <code>int | Sequence[int] | None</code> <p>If not <code>None</code>, data is a single or multiple batches of images.</p> <code>None</code> <code>info</code> <p>Supplementary information about the data.</p> required <code>extent</code> <code>Sequence[float] | None</code> <p>Extent of the map in physical units.</p> <code>None</code> <code>colormap</code> <code>None</code> <p>Name of the colormap to use for plotting.</p> <code>None</code> <code>colorbar</code> <code>bool</code> <p>If <code>True</code>, include the colorbar in the plot.</p> <code>False</code> <code>colorbar_label</code> <code>str | None</code> <p>Label of the colorbar (if enabled).</p> <code>None</code> <code>xlabel</code> <code>str | None</code> <p>Label of the x-axis.</p> <code>None</code> <code>ylabel</code> <code>str | None</code> <p>Label of the y-axis.</p> <code>None</code> <code>savefig</code> <code>bool</code> <p>If <code>True</code>, save the plot to file.</p> <code>False</code> <code>path</code> <code>str | Path | None</code> <p>Filename or filepath where the figure is saved.</p> <code>None</code> <code>show</code> <code>bool</code> <p>If <code>True</code>, show the plot.</p> <code>False</code> <code>close</code> <code>bool</code> <p>If <code>True</code>, closes the figure.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Print results to stdout.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments for <code>matplotlib.pyplot.imshow</code>.</p> <code>{}</code> Source code in <code>skais_mapper/plotting.py</code> <pre><code>@plot_image.register(Sequence)\n@alias_kw(\"colormap\", \"cmap\")\n@alias_kw(\"colorbar\", \"cbar\")\n@alias_kw(\"cbar_label\", \"colorbar_label\")\ndef plot_image_from_batch(\n    data: Sequence[Tensor | np.ndarray | dict],\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Plot map from an array/tensor batch (optionally including metadata).\n\n    Args:\n        data: Array(s) of a map (or maps)\n        batch_idx: If not `None`, data is a single or multiple batches of images.\n        info: Supplementary information about the data.\n        extent: Extent of the map in physical units.\n        colormap: Name of the colormap to use for plotting.\n        colorbar: If `True`, include the colorbar in the plot.\n        colorbar_label: Label of the colorbar (if enabled).\n        xlabel: Label of the x-axis.\n        ylabel: Label of the y-axis.\n        savefig: If `True`, save the plot to file.\n        path: Filename or filepath where the figure is saved.\n        show: If `True`, show the plot.\n        close: If `True`, closes the figure.\n        verbose: Print results to stdout.\n        kwargs: Additional keyword arguments for `matplotlib.pyplot.imshow`.\n    \"\"\"\n    if all([isinstance(d, Tensor) or isinstance(d, np.ndarray) for d in data]):\n        data = data\n        metadata = {}\n    else:\n        data, metadata = data\n    metadata = kwargs.pop(\"info\", metadata)\n    data, metadata = _from_batch(data, metadata, batch_idx=batch_idx)\n    _plot_data(\n        data,\n        metadata,\n        extent=extent,\n        colormap=colormap,\n        colorbar=colorbar,\n        colorbar_label=colorbar_label,\n        xlabel=xlabel,\n        ylabel=ylabel,\n        savefig=savefig,\n        path=path,\n        show=show,\n        close=close,\n        verbose=verbose,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/skais_mapper/plotting/#skais_mapper.plotting.plot_image_quantity","title":"plot_image_quantity","text":"<pre><code>plot_image_quantity(\n    data: au.Quantity,\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: Colormap | None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n)\n</code></pre> <p>Plot map from an astropy.units.Quantity array or batch(es).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>au.Quantity</code> <p>Array(s) of a map (or maps)</p> required <code>batch_idx</code> <code>int | Sequence[int] | None</code> <p>If not <code>None</code>, data is a single or multiple batches of images.</p> <code>None</code> <code>info</code> <p>Supplementary information about the data.</p> required <code>extent</code> <code>Sequence[float] | None</code> <p>Extent of the map in physical units.</p> <code>None</code> <code>colormap</code> <code>Colormap | None</code> <p>Name of the colormap to use for plotting.</p> <code>None</code> <code>colorbar</code> <code>bool</code> <p>If <code>True</code>, include the colorbar in the plot.</p> <code>False</code> <code>colorbar_label</code> <code>str | None</code> <p>Label of the colorbar (if enabled).</p> <code>None</code> <code>xlabel</code> <code>str | None</code> <p>Label of the x-axis.</p> <code>None</code> <code>ylabel</code> <code>str | None</code> <p>Label of the y-axis.</p> <code>None</code> <code>savefig</code> <code>bool</code> <p>If <code>True</code>, save the plot to file.</p> <code>False</code> <code>path</code> <code>str | Path | None</code> <p>Filename or filepath where the figure is saved.</p> <code>None</code> <code>show</code> <code>bool</code> <p>If <code>True</code>, show the plot.</p> <code>False</code> <code>close</code> <code>bool</code> <p>If <code>True</code>, closes the figure.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Print results to stdout.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments for <code>matplotlib.pyplot.imshow</code>.</p> <code>{}</code> Source code in <code>skais_mapper/plotting.py</code> <pre><code>@plot_image.register(au.Quantity)\n@alias_kw(\"colormap\", \"cmap\")\n@alias_kw(\"colorbar\", \"cbar\")\n@alias_kw(\"cbar_label\", \"colorbar_label\")\ndef plot_image_quantity(\n    data: au.Quantity,\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: Colormap | None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Plot map from an astropy.units.Quantity array or batch(es).\n\n    Args:\n        data: Array(s) of a map (or maps)\n        batch_idx: If not `None`, data is a single or multiple batches of images.\n        info: Supplementary information about the data.\n        extent: Extent of the map in physical units.\n        colormap: Name of the colormap to use for plotting.\n        colorbar: If `True`, include the colorbar in the plot.\n        colorbar_label: Label of the colorbar (if enabled).\n        xlabel: Label of the x-axis.\n        ylabel: Label of the y-axis.\n        savefig: If `True`, save the plot to file.\n        path: Filename or filepath where the figure is saved.\n        show: If `True`, show the plot.\n        close: If `True`, closes the figure.\n        verbose: Print results to stdout.\n        kwargs: Additional keyword arguments for `matplotlib.pyplot.imshow`.\n    \"\"\"\n    metadata = kwargs.pop(\"info\", {})\n    data, metadata = _from_batch(data, metadata=metadata, batch_idx=batch_idx)\n    data, units = data.value, data.unit\n    if \"units\" not in metadata:\n        metadata[\"units\"] = f\"{units:latex}\"\n    _plot_data(\n        data,\n        metadata,\n        extent=extent,\n        colormap=colormap,\n        colorbar=colorbar,\n        colorbar_label=colorbar_label,\n        xlabel=xlabel,\n        ylabel=ylabel,\n        savefig=savefig,\n        path=path,\n        show=show,\n        close=close,\n        verbose=verbose,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/skais_mapper/plotting/#skais_mapper.plotting.plot_image_tensor","title":"plot_image_tensor","text":"<pre><code>plot_image_tensor(\n    data: Tensor,\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: Colormap | None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n)\n</code></pre> <p>Plot map from a tensor, or batch(es).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tensor</code> <p>Array(s) of a map (or maps)</p> required <code>batch_idx</code> <code>int | Sequence[int] | None</code> <p>If not <code>None</code>, data is a single or multiple batches of images.</p> <code>None</code> <code>info</code> <p>Supplementary information about the data.</p> required <code>extent</code> <code>Sequence[float] | None</code> <p>Extent of the map in physical units.</p> <code>None</code> <code>colormap</code> <code>Colormap | None</code> <p>Name of the colormap to use for plotting.</p> <code>None</code> <code>colorbar</code> <code>bool</code> <p>If <code>True</code>, include the colorbar in the plot.</p> <code>False</code> <code>colorbar_label</code> <code>str | None</code> <p>Label of the colorbar (if enabled).</p> <code>None</code> <code>xlabel</code> <code>str | None</code> <p>Label of the x-axis.</p> <code>None</code> <code>ylabel</code> <code>str | None</code> <p>Label of the y-axis.</p> <code>None</code> <code>savefig</code> <code>bool</code> <p>If <code>True</code>, save the plot to file.</p> <code>False</code> <code>path</code> <code>str | Path | None</code> <p>Filename or filepath where the figure is saved.</p> <code>None</code> <code>show</code> <code>bool</code> <p>If <code>True</code>, show the plot.</p> <code>False</code> <code>close</code> <code>bool</code> <p>If <code>True</code>, closes the figure.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Print results to stdout.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments for <code>matplotlib.pyplot.imshow</code>.</p> <code>{}</code> Source code in <code>skais_mapper/plotting.py</code> <pre><code>@plot_image.register(Tensor)\n@alias_kw(\"colormap\", \"cmap\")\n@alias_kw(\"colorbar\", \"cbar\")\n@alias_kw(\"colorbar_label\", \"cbar_label\")\ndef plot_image_tensor(\n    data: Tensor,\n    batch_idx: int | Sequence[int] | None = None,\n    extent: Sequence[float] | None = None,\n    colormap: Colormap | None = None,\n    colorbar: bool = False,\n    colorbar_label: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    savefig: bool = False,\n    path: str | Path | None = None,\n    show: bool = False,\n    close: bool = False,\n    verbose: bool = False,\n    **kwargs,\n):\n    \"\"\"Plot map from a tensor, or batch(es).\n\n    Args:\n        data: Array(s) of a map (or maps)\n        batch_idx: If not `None`, data is a single or multiple batches of images.\n        info: Supplementary information about the data.\n        extent: Extent of the map in physical units.\n        colormap: Name of the colormap to use for plotting.\n        colorbar: If `True`, include the colorbar in the plot.\n        colorbar_label: Label of the colorbar (if enabled).\n        xlabel: Label of the x-axis.\n        ylabel: Label of the y-axis.\n        savefig: If `True`, save the plot to file.\n        path: Filename or filepath where the figure is saved.\n        show: If `True`, show the plot.\n        close: If `True`, closes the figure.\n        verbose: Print results to stdout.\n        kwargs: Additional keyword arguments for `matplotlib.pyplot.imshow`.\n    \"\"\"\n    metadata = kwargs.pop(\"info\", {})\n    data, metadata = _from_batch(data, metadata=metadata, batch_idx=batch_idx)\n    _plot_data(\n        data,\n        metadata,\n        extent=extent,\n        colormap=colormap,\n        colorbar=colorbar,\n        colorbar_label=colorbar_label,\n        xlabel=xlabel,\n        ylabel=ylabel,\n        savefig=savefig,\n        path=path,\n        show=show,\n        close=close,\n        verbose=verbose,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/skais_mapper/rotations/","title":"skais_mapper.rotations","text":""},{"location":"reference/skais_mapper/rotations/#skais_mapper.rotations","title":"skais_mapper.rotations","text":"<p>Rotation operators for point cloud arrays.</p> <p>Classes:</p> Name Description <code>R</code> <p>Class of rotation operators.</p>"},{"location":"reference/skais_mapper/rotations/#skais_mapper.rotations.R","title":"R","text":"<pre><code>R(omega: np.ndarray | None = None)\n</code></pre> <p>Class of rotation operators.</p> <p>Initialize rotator object.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>np.ndarray | None</code> <p>Rotation angle in</p> <code>None</code> <p>Methods:</p> Name Description <code>__call__</code> <p>Rotate the input according to this rotation operator.</p> <code>x</code> <p>Rotation operator about the current x-axis by angle theta.</p> <code>y</code> <p>Rotation operator about the current y-axis by angle theta.</p> <code>z</code> <p>Rotation operator about the current z-axis by angle theta.</p> Source code in <code>skais_mapper/rotations.py</code> <pre><code>def __init__(self, omega: np.ndarray | None = None):\n    \"\"\"Initialize rotator object.\n\n    Args:\n        omega: Rotation angle in\n    \"\"\"\n    self.omega = omega\n</code></pre>"},{"location":"reference/skais_mapper/rotations/#skais_mapper.rotations.R.__call__","title":"__call__","text":"<pre><code>__call__(arr: np.ndarray, **kwargs) -&gt; np.ndarray\n</code></pre> <p>Rotate the input according to this rotation operator.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>np.ndarray</code> <p>The array to be rotated</p> required <code>kwargs</code> <p>Dummy keyword arguments</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>arr</code> <code>np.ndarray</code> <p>The rotated array</p> Source code in <code>skais_mapper/rotations.py</code> <pre><code>def __call__(self, arr: np.ndarray, **kwargs) -&gt; np.ndarray:\n    \"\"\"Rotate the input according to this rotation operator.\n\n    Args:\n        arr: The array to be rotated\n        kwargs: Dummy keyword arguments\n\n    Returns:\n        arr: The rotated array\n    \"\"\"\n    if self.omega is None:\n        self.omega = self._x(0)\n    arr = arr @ self.omega.transpose()\n    return arr\n</code></pre>"},{"location":"reference/skais_mapper/rotations/#skais_mapper.rotations.R.x","title":"x  <code>classmethod</code>","text":"<pre><code>x(theta: float, degrees: bool = True) -&gt; TRotation\n</code></pre> <p>Rotation operator about the current x-axis by angle theta.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Rotation angle in degrees or radians (see below)</p> required <code>degrees</code> <code>bool</code> <p>Rotation in degrees, if false in radians</p> <code>True</code> Source code in <code>skais_mapper/rotations.py</code> <pre><code>@classmethod\ndef x(cls, theta: float, degrees: bool = True) -&gt; TRotation:\n    \"\"\"Rotation operator about the current x-axis by angle theta.\n\n    Args:\n        theta: Rotation angle in degrees or radians (see below)\n        degrees: Rotation in degrees, if false in radians\n    \"\"\"\n    omega = cls._x(theta, degrees=degrees)\n    return cls(omega)\n</code></pre>"},{"location":"reference/skais_mapper/rotations/#skais_mapper.rotations.R.y","title":"y  <code>classmethod</code>","text":"<pre><code>y(theta: float, degrees: bool = True) -&gt; TRotation\n</code></pre> <p>Rotation operator about the current y-axis by angle theta.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Rotation angle in degrees or radians (see below)</p> required <code>degrees</code> <code>bool</code> <p>Rotation in degrees, if false in radians</p> <code>True</code> Source code in <code>skais_mapper/rotations.py</code> <pre><code>@classmethod\ndef y(cls, theta: float, degrees: bool = True) -&gt; TRotation:\n    \"\"\"Rotation operator about the current y-axis by angle theta.\n\n    Args:\n        theta: Rotation angle in degrees or radians (see below)\n        degrees: Rotation in degrees, if false in radians\n    \"\"\"\n    omega = cls._y(theta, degrees=degrees)\n    return cls(omega)\n</code></pre>"},{"location":"reference/skais_mapper/rotations/#skais_mapper.rotations.R.z","title":"z  <code>classmethod</code>","text":"<pre><code>z(theta: float, degrees: bool = True) -&gt; TRotation\n</code></pre> <p>Rotation operator about the current z-axis by angle theta.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Rotation angle in degrees or radians (see below)</p> required <code>degrees</code> <code>bool</code> <p>Rotation in degrees, if false in radians</p> <code>True</code> Source code in <code>skais_mapper/rotations.py</code> <pre><code>@classmethod\ndef z(cls, theta: float, degrees: bool = True) -&gt; TRotation:\n    \"\"\"Rotation operator about the current z-axis by angle theta.\n\n    Args:\n        theta: Rotation angle in degrees or radians (see below)\n        degrees: Rotation in degrees, if false in radians\n    \"\"\"\n    omega = cls._z(theta, degrees=degrees)\n    return cls(omega)\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/","title":"skais_mapper.simobjects","text":""},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects","title":"skais_mapper.simobjects","text":"<p>Tools for manipulating data objects from simulations.</p> <p>Classes:</p> Name Description <code>GasolineGalaxy</code> <p>A Gasoline Galaxy parser.</p> <code>SPHGalaxy</code> <p>A generic base SPH Galaxy simulation parser.</p> <code>TNGGalaxy</code> <p>IllustrisTNG Galaxy simulation parser.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.ArepoGalaxy","title":"ArepoGalaxy","text":"<pre><code>ArepoGalaxy(\n    base_path: str | Path,\n    snapshot: int,\n    halo_index: int,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>TNGGalaxy</code></p> <p>An Arepo Galaxy parser (alias to TNGGalaxy for now).</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def __init__(self, base_path: str | Path, snapshot: int, halo_index: int, **kwargs):\n    \"\"\"Initialize a TNGGalaxy instance.\n\n    Args:\n        base_path (str): Base path to the Illustris(TNG) snapshots.\n        snapshot (int): Snapshot ID {0-99}.\n        halo_index (int): Halo index, index of the subhalo ID list.\n        kwargs (dict): Additional keyword arguments\n            - verbose (bool): If True, print information to the command line.\n    \"\"\"\n    kwargs.setdefault(\"verbose\", False)\n    self.base_path = base_path\n    self.snapshot = snapshot\n    self._halo_index = halo_index\n    self.subhalo_ids = self.subhalo_list(base_path, snapshot, verbose=kwargs[\"verbose\"])\n    self.subhalo = self.load_subhalo(self.halo_index, verbose=kwargs[\"verbose\"])\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.GasolineGalaxy","title":"GasolineGalaxy","text":"<pre><code>GasolineGalaxy(\n    ra: float = 0.0,\n    dec: float = 0.0,\n    distance: float = 3.0,\n    peculiar_v: float = 0.0,\n    rotation: Callable | None = None,\n    cosmo_pars: dict | None = None,\n    units: dict | None = None,\n    particle_type: str | None = None,\n    as_float32: bool = False,\n    verbose: bool = False,\n)\n</code></pre> <p>               Bases: <code>SPHGalaxy</code></p> <p>A Gasoline Galaxy parser.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def __init__(\n    self,\n    ra: float = 0.0,\n    dec: float = 0.0,\n    distance: float = 3.0,\n    peculiar_v: float = 0.0,\n    rotation: Callable | None = None,\n    cosmo_pars: dict | None = None,\n    units: dict | None = None,\n    particle_type: str | None = None,\n    as_float32: bool = False,\n    verbose: bool = False,\n):\n    \"\"\"Initialize an SPHGalaxy base class instance.\n\n    Args:\n        ra: The right ascension sky coordinate\n        dec: The declination sky coordinate\n        distance: The distance from observer\n        peculiar_v: The galaxy's peculiar velocity\n        rotation: Arbitrary rotation of the galaxy\n        cosmo_pars: Cosmology settings\n        units: unit system in the simulations\n        particle_type: the particle type name e.g. 'gas', 'dm', or 'star' (see illustris.util)\n        as_float32: If True, load simulation data as 32-bit floats (for efficiency)\n        verbose: If True, print information to the command line\n    \"\"\"\n    self.as_float32 = as_float32\n    self.header = self.load_header()\n    cosmo_pars = self.load_cosmology(cosmo_pars)\n    self.cosmology = CosmoModel(**cosmo_pars)\n    if particle_type is None:\n        particle_type = \"gas\"\n    self._p_idx = tng.util.pidx_from_ptype(particle_type)\n    self.data = self.load_data(as_float32=self.as_float32, verbose=verbose)\n    self.ra = ra * au.deg\n    self.dec = dec * au.deg\n    self.distance = distance * au.Mpc\n    self.peculiar_v = peculiar_v * au.km / au.s\n    self.rotation = rotation\n    if units:\n        self.set_units(**units)\n    self.verbose = verbose\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy","title":"SPHGalaxy","text":"<pre><code>SPHGalaxy(\n    ra: float = 0.0,\n    dec: float = 0.0,\n    distance: float = 3.0,\n    peculiar_v: float = 0.0,\n    rotation: Callable | None = None,\n    cosmo_pars: dict | None = None,\n    units: dict | None = None,\n    particle_type: str | None = None,\n    as_float32: bool = False,\n    verbose: bool = False,\n)\n</code></pre> <p>A generic base SPH Galaxy simulation parser.</p> <p>Initialize an SPHGalaxy base class instance.</p> <p>Parameters:</p> Name Type Description Default <code>ra</code> <code>float</code> <p>The right ascension sky coordinate</p> <code>0.0</code> <code>dec</code> <code>float</code> <p>The declination sky coordinate</p> <code>0.0</code> <code>distance</code> <code>float</code> <p>The distance from observer</p> <code>3.0</code> <code>peculiar_v</code> <code>float</code> <p>The galaxy's peculiar velocity</p> <code>0.0</code> <code>rotation</code> <code>Callable | None</code> <p>Arbitrary rotation of the galaxy</p> <code>None</code> <code>cosmo_pars</code> <code>dict | None</code> <p>Cosmology settings</p> <code>None</code> <code>units</code> <code>dict | None</code> <p>unit system in the simulations</p> <code>None</code> <code>particle_type</code> <code>str | None</code> <p>the particle type name e.g. 'gas', 'dm', or 'star' (see illustris.util)</p> <code>None</code> <code>as_float32</code> <code>bool</code> <p>If True, load simulation data as 32-bit floats (for efficiency)</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print information to the command line</p> <code>False</code> <p>Methods:</p> Name Description <code>angular_distance</code> <p>Calculate the angular distance of the simulation at the given redshift.</p> <code>angular_resolution</code> <p>Calculate the angular scale of the simulation at the given redshift.</p> <code>kd_tree</code> <p>Compute the distance of each gas particle to its k nearest neighbors.</p> <code>load_cosmology</code> <p>Dummy method, to be overridden in subclasses.</p> <code>load_data</code> <p>Dummy method, to be overridden in subclasses.</p> <code>load_header</code> <p>Dummy method, to be overridden in subclasses.</p> <code>set_units</code> <p>Set units in the header attribute.</p> <code>units</code> <p>Get common units from descriptor strings ('l', 'm', 'v', and variants).</p> <p>Attributes:</p> Name Type Description <code>UnitLength</code> <code>au.Quantity</code> <p>The simulation's length unit as astropy.units.Quantity.</p> <code>UnitMass</code> <code>au.Quantity</code> <p>The simulation's mass unit as astropy.units.Quantity.</p> <code>UnitVelocity</code> <code>au.Quantity</code> <p>The simulation's velocity unit as astropy.units.Quantity.</p> <code>boxsize</code> <code>au.Quantity</code> <p>The virtual boxsize of the simulation.</p> <code>cell_positions</code> <code>au.Quantity | None</code> <p>The simulation's cell position data in corresponding units.</p> <code>density</code> <code>au.Quantity | None</code> <p>The simulation's density data in corresponding units.</p> <code>internal_energy</code> <code>au.Quantity | None</code> <p>The simulation's internal energy data in corresponding units.</p> <code>m_H</code> <code>au.Quantity | None</code> <p>The simulation's hydrogen mass data in corresponding units.</p> <code>m_HI</code> <code>au.Quantity | None</code> <p>The simulation's ionized hydrogen mass data in corresponding units.</p> <code>masses</code> <code>au.Quantity | None</code> <p>The simulation's mass data in corresponding units.</p> <code>n_H</code> <code>au.Quantity | None</code> <p>The simulation's hydrogen number density data in corresponding units.</p> <code>n_HI</code> <code>au.Quantity | None</code> <p>The simulation's ionized hydrogen number density data in corresponding units.</p> <code>p_idx</code> <code>int</code> <p>Particle index {0: 'gas', 1: 'dm', 2: 'tracers', 3: 'stars', 4: 'BHs'}.</p> <code>particle_mass</code> <code>au.Quantity | float | None</code> <p>The simulation's particle mass (for constant mass particles).</p> <code>particle_positions</code> <code>au.Quantity | None</code> <p>The simulation's particle position data in corresponding units.</p> <code>particle_type</code> <code>str</code> <p>Particle type {0: 'gas', 1: 'dm', 2: 'tracers', 3: 'stars', 4: 'BHs'}.</p> <code>velocities</code> <code>au.Quantity | None</code> <p>The simulation's particle velocity data in corresponding units.</p> <code>x_H</code> <code>au.Quantity | None</code> <p>The simulation's neutral hydrogen abundance data in corresponding units.</p> <code>x_HI</code> <code>au.Quantity | None</code> <p>The simulation's ionized hydrogen abundance data in corresponding units.</p> <code>x_e</code> <code>au.Quantity | None</code> <p>The simulation's electron abundance data in corresponding units.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def __init__(\n    self,\n    ra: float = 0.0,\n    dec: float = 0.0,\n    distance: float = 3.0,\n    peculiar_v: float = 0.0,\n    rotation: Callable | None = None,\n    cosmo_pars: dict | None = None,\n    units: dict | None = None,\n    particle_type: str | None = None,\n    as_float32: bool = False,\n    verbose: bool = False,\n):\n    \"\"\"Initialize an SPHGalaxy base class instance.\n\n    Args:\n        ra: The right ascension sky coordinate\n        dec: The declination sky coordinate\n        distance: The distance from observer\n        peculiar_v: The galaxy's peculiar velocity\n        rotation: Arbitrary rotation of the galaxy\n        cosmo_pars: Cosmology settings\n        units: unit system in the simulations\n        particle_type: the particle type name e.g. 'gas', 'dm', or 'star' (see illustris.util)\n        as_float32: If True, load simulation data as 32-bit floats (for efficiency)\n        verbose: If True, print information to the command line\n    \"\"\"\n    self.as_float32 = as_float32\n    self.header = self.load_header()\n    cosmo_pars = self.load_cosmology(cosmo_pars)\n    self.cosmology = CosmoModel(**cosmo_pars)\n    if particle_type is None:\n        particle_type = \"gas\"\n    self._p_idx = tng.util.pidx_from_ptype(particle_type)\n    self.data = self.load_data(as_float32=self.as_float32, verbose=verbose)\n    self.ra = ra * au.deg\n    self.dec = dec * au.deg\n    self.distance = distance * au.Mpc\n    self.peculiar_v = peculiar_v * au.km / au.s\n    self.rotation = rotation\n    if units:\n        self.set_units(**units)\n    self.verbose = verbose\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.UnitLength","title":"UnitLength  <code>property</code>","text":"<pre><code>UnitLength: au.Quantity\n</code></pre> <p>The simulation's length unit as astropy.units.Quantity.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.UnitMass","title":"UnitMass  <code>property</code>","text":"<pre><code>UnitMass: au.Quantity\n</code></pre> <p>The simulation's mass unit as astropy.units.Quantity.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.UnitVelocity","title":"UnitVelocity  <code>property</code>","text":"<pre><code>UnitVelocity: au.Quantity\n</code></pre> <p>The simulation's velocity unit as astropy.units.Quantity.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.boxsize","title":"boxsize  <code>property</code>","text":"<pre><code>boxsize: au.Quantity\n</code></pre> <p>The virtual boxsize of the simulation.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.cell_positions","title":"cell_positions  <code>property</code>","text":"<pre><code>cell_positions: au.Quantity | None\n</code></pre> <p>The simulation's cell position data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.density","title":"density  <code>property</code>","text":"<pre><code>density: au.Quantity | None\n</code></pre> <p>The simulation's density data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.internal_energy","title":"internal_energy  <code>property</code>","text":"<pre><code>internal_energy: au.Quantity | None\n</code></pre> <p>The simulation's internal energy data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.m_H","title":"m_H  <code>property</code>","text":"<pre><code>m_H: au.Quantity | None\n</code></pre> <p>The simulation's hydrogen mass data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.m_HI","title":"m_HI  <code>property</code>","text":"<pre><code>m_HI: au.Quantity | None\n</code></pre> <p>The simulation's ionized hydrogen mass data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.masses","title":"masses  <code>property</code>","text":"<pre><code>masses: au.Quantity | None\n</code></pre> <p>The simulation's mass data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.n_H","title":"n_H  <code>property</code>","text":"<pre><code>n_H: au.Quantity | None\n</code></pre> <p>The simulation's hydrogen number density data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.n_HI","title":"n_HI  <code>property</code>","text":"<pre><code>n_HI: au.Quantity | None\n</code></pre> <p>The simulation's ionized hydrogen number density data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.p_idx","title":"p_idx  <code>property</code> <code>writable</code>","text":"<pre><code>p_idx: int\n</code></pre> <p>Particle index {0: 'gas', 1: 'dm', 2: 'tracers', 3: 'stars', 4: 'BHs'}.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.particle_mass","title":"particle_mass  <code>property</code>","text":"<pre><code>particle_mass: au.Quantity | float | None\n</code></pre> <p>The simulation's particle mass (for constant mass particles).</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.particle_positions","title":"particle_positions  <code>property</code>","text":"<pre><code>particle_positions: au.Quantity | None\n</code></pre> <p>The simulation's particle position data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.particle_type","title":"particle_type  <code>property</code> <code>writable</code>","text":"<pre><code>particle_type: str\n</code></pre> <p>Particle type {0: 'gas', 1: 'dm', 2: 'tracers', 3: 'stars', 4: 'BHs'}.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.velocities","title":"velocities  <code>property</code>","text":"<pre><code>velocities: au.Quantity | None\n</code></pre> <p>The simulation's particle velocity data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.x_H","title":"x_H  <code>property</code>","text":"<pre><code>x_H: au.Quantity | None\n</code></pre> <p>The simulation's neutral hydrogen abundance data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.x_HI","title":"x_HI  <code>property</code>","text":"<pre><code>x_HI: au.Quantity | None\n</code></pre> <p>The simulation's ionized hydrogen abundance data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.x_e","title":"x_e  <code>property</code>","text":"<pre><code>x_e: au.Quantity | None\n</code></pre> <p>The simulation's electron abundance data in corresponding units.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.angular_distance","title":"angular_distance","text":"<pre><code>angular_distance(eps: float = 0.0001) -&gt; float\n</code></pre> <p>Calculate the angular distance of the simulation at the given redshift.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>minimum cutoff value for the redshift</p> <code>0.0001</code> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def angular_distance(self, eps: float = 1e-4) -&gt; float:\n    \"\"\"Calculate the angular distance of the simulation at the given redshift.\n\n    Args:\n        eps: minimum cutoff value for the redshift\n    \"\"\"\n    z = self.cosmology.z\n    z += eps if z &lt; eps else 0\n    dz = self.cosmology.d_z(z, cosmo_model=self.cosmology, scaled=False)\n    dang = self.cosmology.d_z2kpc(dz, cosmo_model=self.cosmology)\n    return dang\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.angular_resolution","title":"angular_resolution","text":"<pre><code>angular_resolution(\n    eps: float = 0.0001,\n) -&gt; tuple[float, float]\n</code></pre> <p>Calculate the angular scale of the simulation at the given redshift.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>minimum cutoff value for the redshift</p> <code>0.0001</code> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def angular_resolution(self, eps: float = 1e-4) -&gt; tuple[float, float]:\n    \"\"\"Calculate the angular scale of the simulation at the given redshift.\n\n    Args:\n        eps: minimum cutoff value for the redshift\n    \"\"\"\n    z = self.cosmology.z\n    z += eps if z &lt; eps else 0\n    dz = self.cosmology.d_z(z, cosmo_model=self.cosmology, scaled=True)\n    arcsec2kpc = self.cosmology.arcsec2kpc(z, dz)\n    return 1.0 / arcsec2kpc.to(au.kpc / au.deg), z\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.kd_tree","title":"kd_tree","text":"<pre><code>kd_tree(\n    k: int = 8,\n    threads: int = 1,\n    epsilon: float = 0.0001,\n    as_float32: bool = False,\n    verbose: bool = True,\n) -&gt; au.Quantity | NDArray\n</code></pre> <p>Compute the distance of each gas particle to its k nearest neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of nearest neighbors.</p> <code>8</code> <code>threads</code> <code>int</code> <p>Number of computing threads.</p> <code>1</code> <code>epsilon</code> <code>float</code> <p>Small increase of the box size to avoid segfaults</p> <code>0.0001</code> <code>as_float32</code> <code>bool</code> <p>If True, load simulation data as 32-bit floats (for efficiency)</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print out results to the command line.</p> <code>True</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The distance of each particle to its farthest neighbor</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def kd_tree(\n    self,\n    k: int = 8,\n    threads: int = 1,\n    epsilon: float = 1.0e-4,\n    as_float32: bool = False,\n    verbose: bool = True,\n) -&gt; au.Quantity | NDArray:\n    \"\"\"Compute the distance of each gas particle to its k nearest neighbors.\n\n    Args:\n        k: Number of nearest neighbors.\n        threads: Number of computing threads.\n        epsilon: Small increase of the box size to avoid segfaults\n        as_float32: If True, load simulation data as 32-bit floats (for efficiency)\n        verbose: If True, print out results to the command line.\n\n    Returns:\n        (np.ndarray): The distance of each particle to its farthest neighbor\n    \"\"\"\n    p = self.particle_positions\n    if p is None:\n        return None\n    p = p.to(au.kpc)\n    boxsize = (1 + epsilon) * self.boxsize.to(au.kpc)\n    if verbose:\n        print(\"Building KDTree...\")\n    t_ini = time.time()\n    kdtree = sp.spatial.cKDTree(p, leafsize=16, boxsize=boxsize)\n    if verbose:\n        print(f\"Time to build KDTree: {time.time() - t_ini:.3f} secs.\")\n    if verbose:\n        print(\"Querying KDTree...\")\n    dist, _ = kdtree.query(p, k, workers=threads)\n    if verbose:\n        print(f\"Time to querying KDTree: {time.time() - t_ini:.3f} secs.\")\n    if as_float32:\n        return (dist[:, -1] * au.kpc).astype(np.float32)\n    return dist[:, -1] * au.kpc\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.load_cosmology","title":"load_cosmology","text":"<pre><code>load_cosmology(\n    cosmo_pars: dict | None, in_place: bool = True\n) -&gt; dict\n</code></pre> <p>Dummy method, to be overridden in subclasses.</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with cosmological parameters pulled from a header or set manually. The dictionary will be used for the CosmoModel dataclass.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def load_cosmology(self, cosmo_pars: dict | None, in_place: bool = True) -&gt; dict:\n    \"\"\"Dummy method, to be overridden in subclasses.\n\n    Returns:\n        (dict): a dictionary with cosmological parameters pulled from a header\n            or set manually. The dictionary will be used for the CosmoModel\n            dataclass.\n    \"\"\"\n    if cosmo_pars is None:\n        cosmo_pars = {}\n    if in_place:\n        self.cosmology = CosmoModel(**cosmo_pars)\n    return cosmo_pars\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.load_data","title":"load_data","text":"<pre><code>load_data(**kwargs) -&gt; dict\n</code></pre> <p>Dummy method, to be overridden in subclasses.</p> <p>Returns:</p> Type Description <code>dict</code> <p>the data dictionary loaded from the simulations containing: - 'Density', 'Masses', 'Coordinates', 'Velocities', 'InternalEnergy',   'ElectronAbundance' - optionally 'CenterOfMass', 'GFM_Metals' (axis 1 should contain   hydrogen gas fractions), 'NeutralHydrogenAbundance'</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def load_data(self, **kwargs) -&gt; dict:\n    \"\"\"Dummy method, to be overridden in subclasses.\n\n    Returns:\n        (dict): the data dictionary loaded from the simulations containing:\n            - 'Density', 'Masses', 'Coordinates', 'Velocities', 'InternalEnergy',\n              'ElectronAbundance'\n            - optionally 'CenterOfMass', 'GFM_Metals' (axis 1 should contain\n              hydrogen gas fractions), 'NeutralHydrogenAbundance'\n    \"\"\"\n    kwargs.setdefault(\n        \"fields\",\n        self.primary_hdf5_fields[self.p_idx] + self.optional_hdf5_fields[self.p_idx],\n    )\n    data = {k: None for k in kwargs[\"fields\"]}\n    return data\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.load_header","title":"load_header","text":"<pre><code>load_header() -&gt; dict\n</code></pre> <p>Dummy method, to be overridden in subclasses.</p> <p>Returns:</p> Type Description <code>dict</code> <p>the header dictionary which should contain - a 'snapshot' and 'catalog' subdictionary - the 'snapshot' subdictionary should contain     - 'UnitLength_in_cm', 'UnitVelocity_in_cm_per_s', 'UnitMass_in_g'     - 'OmegaLambda', 'Omega0', 'Redshift' / 'Time', 'HubbleParam'     - optionally: 'OmegaK'</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def load_header(self) -&gt; dict:\n    \"\"\"Dummy method, to be overridden in subclasses.\n\n    Returns:\n        (dict): the header dictionary which should contain\n            - a 'snapshot' and 'catalog' subdictionary\n            - the 'snapshot' subdictionary should contain\n                - 'UnitLength_in_cm', 'UnitVelocity_in_cm_per_s', 'UnitMass_in_g'\n                - 'OmegaLambda', 'Omega0', 'Redshift' / 'Time', 'HubbleParam'\n                - optionally: 'OmegaK'\n    \"\"\"\n    self.header = {}\n    self.header[\"snapshot\"] = {}\n    self.header[\"snapshot\"][\"UnitLength_in_cm\"] = 3.085678e21\n    self.header[\"snapshot\"][\"UnitVelocity_in_cm_per_s\"] = 1e5\n    self.header[\"snapshot\"][\"UnitMass_in_g\"] = 1.989e43\n    return self.header\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.set_units","title":"set_units","text":"<pre><code>set_units(length: float, velocity: float, mass: float)\n</code></pre> <p>Set units in the header attribute.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>length unit</p> required <code>velocity</code> <code>float</code> <p>velocity unit (sets the time unit implicitly)</p> required <code>mass</code> <code>float</code> <p>mass unit</p> required Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def set_units(self, length: float, velocity: float, mass: float):\n    \"\"\"Set units in the header attribute.\n\n    Args:\n        length: length unit\n        velocity: velocity unit (sets the time unit implicitly)\n        mass: mass unit\n    \"\"\"\n    if not hasattr(self, \"header\"):\n        self.header = self.load_header()\n    self.header[\"snapshot\"][\"UnitLength_in_cm\"] = length\n    self.header[\"snapshot\"][\"UnitVelocity_in_cm_per_s\"] = velocity\n    self.header[\"snapshot\"][\"UnitMass_in_g\"] = mass\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.SPHGalaxy.units","title":"units","text":"<pre><code>units(u: str) -&gt; au.Quantity\n</code></pre> <p>Get common units from descriptor strings ('l', 'm', 'v', and variants).</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>the unit string describing the dimensionality; l -&gt; length; m -&gt; mass; v -&gt; velocity; t -&gt; time; vp -&gt; peculiar velocity; sqrtP -&gt; square root of pressure; c[] -&gt; comoving quantities; []/h -&gt; quantities divided by the dimensionless Hubble const.</p> required <p>Returns:</p> Type Description <code>astropy.units.Quantity</code> <p>specified (scaled/composite) unit.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def units(self, u: str) -&gt; au.Quantity:\n    \"\"\"Get common units from descriptor strings ('l', 'm', 'v', and variants).\n\n    Args:\n        u: the unit string describing the dimensionality;\n            l -&gt; length;\n            m -&gt; mass;\n            v -&gt; velocity;\n            t -&gt; time;\n            vp -&gt; peculiar velocity;\n            sqrtP -&gt; square root of pressure;\n            c[] -&gt; comoving quantities;\n            []/h -&gt; quantities divided by the dimensionless Hubble const.\n\n    Returns:\n        (astropy.units.Quantity): specified (scaled/composite) unit.\n    \"\"\"\n    h = self.cosmology.h\n    a = self.cosmology.a\n    match u:\n        case \"l\":\n            return self.UnitLength\n        case \"m\":\n            return self.UnitMass\n        case \"v\":\n            return self.UnitVelocity\n        case \"t\":\n            return self.UnitLength / self.UnitVelocity\n        case \"l/h\":\n            return self.UnitLength * (a / h)\n        case \"m/h\":\n            return self.UnitMass / h\n        case \"vp\":\n            return self.UnitVelocity * np.sqrt(a)\n        case \"sqrtP\":\n            return (\n                h\n                / a**2\n                * (self.UnitMass / self.UnitLength) ** (1.0 / 2)\n                / (self.UnitLength / self.UnitVelocity)\n            )\n        case _:\n            return 1\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy","title":"TNGGalaxy","text":"<pre><code>TNGGalaxy(\n    base_path: str | Path,\n    snapshot: int,\n    halo_index: int,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>SPHGalaxy</code></p> <p>IllustrisTNG Galaxy simulation parser.</p> <p>Initialize a TNGGalaxy instance.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>halo_index</code> <code>int</code> <p>Halo index, index of the subhalo ID list.</p> required <code>kwargs</code> <code>dict</code> <p>Additional keyword arguments - verbose (bool): If True, print information to the command line.</p> <code>{}</code> <p>Methods:</p> Name Description <code>generate_map</code> <p>Generate raytracing projection map.</p> <code>get_mapping_arrays</code> <p>Fetch data (arrays or scalars) from a TNGGalaxy object given keys.</p> <code>load_cosmology</code> <p>Load the cosmological parameters from the header dictionary.</p> <code>load_data</code> <p>Load the snapshot's relevant subset data of the specified group ID.</p> <code>load_header</code> <p>Load the header (overrides parent class method).</p> <code>load_subhalo</code> <p>Load the FOF subhalo metadata of a specified group ID.</p> <code>p_idx</code> <p>Setter for particle index.</p> <code>subhalo_list</code> <p>Pull a list of subhalo IDs from the snapshot's FOF group catalog.</p> <p>Attributes:</p> Name Type Description <code>N_particles</code> <code>int</code> <p>Total number of particles in the galaxy.</p> <code>N_particles_type</code> <code>list[int]</code> <p>Number of particles per type in the galaxy.</p> <code>center</code> <code>au.Quantity</code> <p>Center position getter of the galaxy in units of L/h.</p> <code>halo_index</code> <p>The halo index getter.</p> <code>hsml</code> <p>Average kernel smoothing length.</p> <code>magnetic_field</code> <p>Magnetic vector field in cgs units of Gauss.</p> <code>magnetic_field_strength</code> <p>Magnetic field strength in units of SI Gauss.</p> <code>r_cell</code> <p>Alias for radii.</p> <code>radii</code> <p>Particle radius distances assuming spherical shape.</p> <code>temperature</code> <p>Temperature data getter in units of Kelvin.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def __init__(self, base_path: str | Path, snapshot: int, halo_index: int, **kwargs):\n    \"\"\"Initialize a TNGGalaxy instance.\n\n    Args:\n        base_path (str): Base path to the Illustris(TNG) snapshots.\n        snapshot (int): Snapshot ID {0-99}.\n        halo_index (int): Halo index, index of the subhalo ID list.\n        kwargs (dict): Additional keyword arguments\n            - verbose (bool): If True, print information to the command line.\n    \"\"\"\n    kwargs.setdefault(\"verbose\", False)\n    self.base_path = base_path\n    self.snapshot = snapshot\n    self._halo_index = halo_index\n    self.subhalo_ids = self.subhalo_list(base_path, snapshot, verbose=kwargs[\"verbose\"])\n    self.subhalo = self.load_subhalo(self.halo_index, verbose=kwargs[\"verbose\"])\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.N_particles","title":"N_particles  <code>property</code>","text":"<pre><code>N_particles: int\n</code></pre> <p>Total number of particles in the galaxy.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.N_particles_type","title":"N_particles_type  <code>property</code>","text":"<pre><code>N_particles_type: list[int]\n</code></pre> <p>Number of particles per type in the galaxy.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.center","title":"center  <code>property</code>","text":"<pre><code>center: au.Quantity\n</code></pre> <p>Center position getter of the galaxy in units of L/h.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.halo_index","title":"halo_index  <code>property</code> <code>writable</code>","text":"<pre><code>halo_index\n</code></pre> <p>The halo index getter.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.hsml","title":"hsml  <code>property</code>","text":"<pre><code>hsml\n</code></pre> <p>Average kernel smoothing length.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.magnetic_field","title":"magnetic_field  <code>property</code>","text":"<pre><code>magnetic_field\n</code></pre> <p>Magnetic vector field in cgs units of Gauss.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.magnetic_field_strength","title":"magnetic_field_strength  <code>property</code>","text":"<pre><code>magnetic_field_strength\n</code></pre> <p>Magnetic field strength in units of SI Gauss.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.r_cell","title":"r_cell  <code>property</code>","text":"<pre><code>r_cell\n</code></pre> <p>Alias for radii.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.radii","title":"radii  <code>property</code>","text":"<pre><code>radii\n</code></pre> <p>Particle radius distances assuming spherical shape.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature\n</code></pre> <p>Temperature data getter in units of Kelvin.</p>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.generate_map","title":"generate_map","text":"<pre><code>generate_map(\n    keys: list[str] | None = None,\n    factors: list[float] | None = None,\n    use_half_mass_rad: bool = True,\n    fh: float = 3,\n    grid_size: int = 512,\n    xaxis: int = 0,\n    yaxis: int = 1,\n    periodic: bool = True,\n    assignment_func: Callable = voronoi_RT_2D,\n    tracers: int | None = None,\n    divisions: int | None = None,\n    rot: list[int] | list[float] | None = None,\n    verbose: bool = False,\n) -&gt; tuple[au.Quantity, au.Quantity, int] | Any\n</code></pre> <p>Generate raytracing projection map.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str] | None</code> <p>Keys to fetch data for projecting onto the map.</p> <code>None</code> <code>factors</code> <code>list[float] | None</code> <p>Factors for modifying the projection data.</p> <code>None</code> <code>use_half_mass_rad</code> <code>bool</code> <p>If True, the SubhaloHalfmassRad from the subfind catalog is used for selecting relevant particles. Otherwise, a fraction of the entire particle extent is used.</p> <code>True</code> <code>fh</code> <code>float</code> <p>Expansion factor for the SPH particle radii.</p> <code>3</code> <code>grid_size</code> <code>int</code> <p>The size of the maps/images. Default: 512.</p> <code>512</code> <code>xaxis</code> <code>int</code> <p>Projection axis for x.</p> <code>0</code> <code>yaxis</code> <code>int</code> <p>Projection axis for y.</p> <code>1</code> <code>periodic</code> <code>bool</code> <p>Use periodic boundary conditions for the projection.</p> <code>True</code> <code>assignment_func</code> <code>Callable</code> <p>Mass assignment algorithm; one of [voronoi_RT_2D, voronoi_NGP_2D].</p> <code>voronoi_RT_2D</code> <code>tracers</code> <code>int | None</code> <p>Number of tracer particles to use for the Nearest Grid Point algorithm.</p> <code>None</code> <code>divisions</code> <code>int | None</code> <p>Number of sphere divisions to use for the Nearest Grid Point algorithm.</p> <code>None</code> <code>rot</code> <code>list[int] | list[float] | None</code> <p>Angles to rotate the particle positions.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, print status updates to command line.</p> <code>False</code> <p>Returns:</p> Type Description <code>(np.ndarray, np.ndarray, int)</code> <p>The projected map, the map extent, and number of particles projected.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def generate_map(\n    self,\n    keys: list[str] | None = None,\n    factors: list[float] | None = None,\n    use_half_mass_rad: bool = True,\n    fh: float = 3,\n    grid_size: int = 512,\n    xaxis: int = 0,\n    yaxis: int = 1,\n    periodic: bool = True,\n    assignment_func: Callable = voronoi_RT_2D,\n    tracers: int | None = None,\n    divisions: int | None = None,\n    rot: list[int] | list[float] | None = None,\n    verbose: bool = False,\n) -&gt; tuple[au.Quantity, au.Quantity, int] | Any:\n    \"\"\"Generate raytracing projection map.\n\n    Args:\n        keys: Keys to fetch data for projecting onto the map.\n        factors: Factors for modifying the projection data.\n        use_half_mass_rad:\n          If True, the SubhaloHalfmassRad from the subfind catalog is used for\n          selecting relevant particles. Otherwise, a fraction of the entire\n          particle extent is used.\n        fh: Expansion factor for the SPH particle radii.\n        grid_size: The size of the maps/images. Default: 512.\n        xaxis: Projection axis for x.\n        yaxis: Projection axis for y.\n        periodic: Use periodic boundary conditions for the projection.\n        assignment_func: Mass assignment algorithm; one of\n          [voronoi_RT_2D, voronoi_NGP_2D].\n        tracers: Number of tracer particles to use for the Nearest Grid Point algorithm.\n        divisions: Number of sphere divisions to use for the Nearest Grid Point algorithm.\n        rot:\n          Angles to rotate the particle positions.\n        verbose: If True, print status updates to command line.\n\n    Returns:\n        (np.ndarray, np.ndarray, int): The projected map, the map extent, and\n           number of particles projected.\n    \"\"\"\n    L, M, T = au.Mpc, au.Msun, au.K\n    projected = np.zeros((grid_size, grid_size), dtype=np.float64)\n    if keys is None:\n        keys = [\"particle_positions\", \"masses\", \"radii\", \"center\"]\n    if factors is None:\n        factors = [1, 1, fh, 1]\n    if use_half_mass_rad:\n        if \"SubhaloHalfmassRadType\" not in keys:\n            keys += [\"SubhaloHalfmassRadType\"]\n            factors += [self.units(\"l/h\")]\n        else:\n            factors.insert(keys.index(\"SubhaloHalfmassRadType\"), self.units(\"l/h\"))\n    if assignment_func not in [voronoi_RT_2D, voronoi_NGP_2D]:\n        raise ValueError(f\"Assignment function `{assignment_func.__name__}` not compatible.\")\n    uarrs = self.get_mapping_arrays(keys=keys, factors=factors, verbose=verbose)\n    if rot is not None:\n        rot_op = R.y(rot[1]) * R.x(rot[0])\n        uarrs[0] = rot_op(uarrs[0]).astype(np.float32)\n        uarrs[3] = rot_op(uarrs[3]).astype(np.float32)\n    # Ngids = uarrs[0].shape[0]\n    hmr = uarrs[4][0] if use_half_mass_rad else None  # always use gas (p_idx=0) hmr\n    # hmr = (uarrs[4][obj.p_idx] if use_half_mass_rad else None)\n    idcs, limits = indices_within_box(uarrs[0], uarrs[3], radius=hmr, verbose=verbose)\n    hmr2 = limits[3] - limits[0]\n    args = strip_ap_units(*uarrs[:3], *limits[:2], hmr2, mask=idcs, units=[L, M, T * M])\n    if tracers is not None:\n        args.append(tracers)\n    else:\n        args.append(xaxis)\n    if divisions is not None:\n        args.append(divisions)\n    else:\n        args.append(yaxis)\n    if verbose:\n        print(f\"Raytracing particles with `{assignment_func.__name__}`...\")\n    try:\n        assignment_func(projected, *args, periodic, verbose=True)\n    except Exception as e:\n        print(e)\n        return projected * uarrs[1].unit / L**2\n    projected = projected * uarrs[1].unit / L**2\n    return projected, hmr2 / 2 * np.array([-1, 1, -1, 1]), idcs.shape[0]\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.get_mapping_arrays","title":"get_mapping_arrays","text":"<pre><code>get_mapping_arrays(\n    keys: list[str] | None = None,\n    factors: list[float] = None,\n    verbose: bool = False,\n) -&gt; list\n</code></pre> <p>Fetch data (arrays or scalars) from a TNGGalaxy object given keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str] | None</code> <p>Keys to fetch data.</p> <code>None</code> <code>factors</code> <code>list[float]</code> <p>Factors for modifying the fetched data.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, print status updates to command line.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>List of fetched data arrays or scalars.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def get_mapping_arrays(\n    self,\n    keys: list[str] | None = None,\n    factors: list[float] = None,\n    verbose: bool = False,\n) -&gt; list:\n    \"\"\"Fetch data (arrays or scalars) from a TNGGalaxy object given keys.\n\n    Args:\n        keys: Keys to fetch data.\n        factors: Factors for modifying the fetched data.\n        verbose: If True, print status updates to command line.\n\n    Returns:\n        (list): List of fetched data arrays or scalars.\n    \"\"\"\n    if keys is None:\n        keys = [\"particle_positions\", \"masses\", \"radii\"]\n    if factors is None:\n        factors = [1, 1, 3]\n    vals = []\n    for key, f in zip(keys, factors):\n        if isinstance(key, tuple | list):\n            try:\n                v1 = getattr(self, key[0])\n            except Exception:\n                v1 = self.subhalo[key[0]]\n            try:\n                v2 = getattr(self, key[1])\n            except Exception:\n                v2 = self.subhalo[key[1]]\n            v = v1 * v2 * f\n        else:\n            try:\n                v = getattr(self, key) * f\n            except Exception:\n                v = self.subhalo[key] * f\n        vals.append(v)\n    if verbose:\n        print(f\"Loading arrays: {keys}...\")\n    return [*vals]\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.load_cosmology","title":"load_cosmology","text":"<pre><code>load_cosmology(\n    cosmo_pars: dict | None = None, in_place: bool = True\n) -&gt; dict\n</code></pre> <p>Load the cosmological parameters from the header dictionary.</p> <p>Note: This overrides the parent class method.</p> <p>Parameters:</p> Name Type Description Default <code>cosmo_pars</code> <code>dict | None</code> <p>The default dictionary for the CosmoModel dataclass.</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>Load CosmoModel into instanace property <code>cosmology</code> directly.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with cosmological parameters pulled the header.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def load_cosmology(self, cosmo_pars: dict | None = None, in_place: bool = True) -&gt; dict:\n    \"\"\"Load the cosmological parameters from the header dictionary.\n\n    Note: This overrides the parent class method.\n\n    Args:\n        cosmo_pars: The default dictionary for the CosmoModel dataclass.\n        in_place: Load CosmoModel into instanace property `cosmology` directly.\n\n    Returns:\n        (dict): a dictionary with cosmological parameters pulled the header.\n    \"\"\"\n    cosmo_pars = {} if cosmo_pars is None else cosmo_pars\n    cosmo_pars.setdefault(\"omega_l\", self.header[\"snapshot\"].get(\"OmegaLambda\", 0.6911))\n    cosmo_pars.setdefault(\"omega_m\", self.header[\"snapshot\"].get(\"Omega0\", 0.3089))\n    cosmo_pars.setdefault(\"omega_k\", self.header[\"snapshot\"].get(\"OmegaK\", 0))\n    cosmo_pars.setdefault(\"z\", self.header[\"snapshot\"].get(\"Redshift\", None))\n    cosmo_pars.setdefault(\"z\", 1.0 / self.header[\"snapshot\"].get(\"Time\", 1) - 1)\n    cosmo_pars.setdefault(\"h\", self.header[\"snapshot\"].get(\"HubbleParam\", 0.6774))\n    if in_place:\n        self.cosmology = CosmoModel(**cosmo_pars)\n    return cosmo_pars\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.load_data","title":"load_data","text":"<pre><code>load_data(\n    halo_index: int | None = None,\n    primary_fields: list[str] | None = None,\n    optional_fields: list[str] | None = None,\n    particle_type: str | None = None,\n    **kwargs,\n)\n</code></pre> <p>Load the snapshot's relevant subset data of the specified group ID.</p> <p>Parameters:</p> Name Type Description Default <code>halo_index</code> <code>int | None</code> <p>Galaxy/Halo ID in the simulation.</p> <code>None</code> <code>primary_fields</code> <code>list[str] | None</code> <p>The primary fields to load (less fields load faster)</p> <code>None</code> <code>optional_fields</code> <code>list[str] | None</code> <p>The secondary fields to load (less fields load faster)</p> <code>None</code> <code>particle_type</code> <code>str | None</code> <p>Manually set the particle type.</p> <code>None</code> <code>kwargs</code> <ul> <li>verbose (bool): Print information to the command-line.</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary containing the relevant snapshot data</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def load_data(\n    self,\n    halo_index: int | None = None,\n    primary_fields: list[str] | None = None,\n    optional_fields: list[str] | None = None,\n    particle_type: str | None = None,\n    **kwargs,\n):\n    \"\"\"Load the snapshot's relevant subset data of the specified group ID.\n\n    Args:\n        halo_index: Galaxy/Halo ID in the simulation.\n        primary_fields: The primary fields to load (less fields load faster)\n        optional_fields: The secondary fields to load (less fields load faster)\n        particle_type: Manually set the particle type.\n        kwargs:\n          - verbose (bool): Print information to the command-line.\n\n    Returns:\n        (dict): dictionary containing the relevant snapshot data\n    \"\"\"\n    kwargs.setdefault(\"verbose\", False)\n    verbose = kwargs.pop(\"verbose\")\n    if particle_type is not None:\n        p_idx = tng.util.pidx_from_ptype(particle_type)\n    else:\n        p_idx = self.p_idx\n        particle_type = self.particle_type\n    if primary_fields is None:\n        primary_fields = self.primary_hdf5_fields[p_idx]\n    if optional_fields is None:\n        optional_fields = self.optional_hdf5_fields[p_idx]\n    if halo_index is None or halo_index &lt; 0 or halo_index &gt;= len(self.subhalo_ids):\n        halo_index = self.halo_index\n    subset = tng.snapshots.snapshot_offsets(self.base_path, self.snapshot, halo_index, \"Group\")\n    if verbose:\n        print(f\"Loading primary fields from snapshot [{particle_type}]: {self.snapshot}\")\n    data = tng.snapshots.load_snapshot(\n        self.base_path,\n        self.snapshot,\n        particle_type,\n        subset=subset,\n        fields=primary_fields,\n        **kwargs,\n    )\n    try:\n        if verbose:\n            print(f\"Loading optional fields from snapshot [{particle_type}]: {self.snapshot}\")\n        data.update(\n            tng.snapshots.load_snapshot(\n                self.base_path,\n                self.snapshot,\n                particle_type,\n                subset=subset,\n                fields=optional_fields,\n                as_array=False,\n                **kwargs,\n            )\n        )\n    except Exception as ex:\n        if (\"Particle type\" in ex.args[0]) and (\"does not have field\" in ex.args[0]):\n            for f in optional_fields:\n                data[f] = None\n        else:\n            raise\n    if particle_type == \"gas\" and (\"GFM_Metals\" not in data or data[\"GFM_Metals\"] is None):\n        data[\"GFM_Metals\"] = np.array([[0.76]])\n    if \"CenterOfMass\" not in data or data[\"CenterOfMass\"] is None:\n        data[\"CenterOfMass\"] = data[\"Coordinates\"]\n    return data\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.load_header","title":"load_header","text":"<pre><code>load_header() -&gt; dict\n</code></pre> <p>Load the header (overrides parent class method).</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary containing the headers from a snapshot and the corresponding group catalog.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def load_header(self) -&gt; dict:\n    \"\"\"Load the header (overrides parent class method).\n\n    Returns:\n        (dict): a dictionary containing the headers from a snapshot and the\n          corresponding group catalog.\n    \"\"\"\n    header = {}\n    header[\"catalog\"] = tng.groupcat.load_header(self.base_path, self.snapshot)\n    header[\"snapshot\"] = tng.snapshots.load_header(self.base_path, self.snapshot)\n    return header\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.load_subhalo","title":"load_subhalo","text":"<pre><code>load_subhalo(\n    halo_index: int = 0, verbose: bool = False\n) -&gt; dict\n</code></pre> <p>Load the FOF subhalo metadata of a specified group ID.</p> <p>Parameters:</p> Name Type Description Default <code>halo_index</code> <code>int</code> <p>the group ID corresponding to a subhalo ID</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Print status information to the command-line.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary containing the FOF subhalo metadata</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def load_subhalo(self, halo_index: int = 0, verbose: bool = False) -&gt; dict:\n    \"\"\"Load the FOF subhalo metadata of a specified group ID.\n\n    Args:\n        halo_index: the group ID corresponding to a subhalo ID\n        verbose: Print status information to the command-line.\n\n    Returns:\n        (dict): dictionary containing the FOF subhalo metadata\n    \"\"\"\n    if halo_index &lt; 0 or halo_index &gt;= len(self.subhalo_ids):\n        halo_index = 0\n    sh_id = self.subhalo_ids[halo_index]\n    if verbose:\n        print(f\"Loading group: {sh_id}\")\n    data = tng.groupcat.load_single(self.base_path, self.snapshot, subhalo_id=sh_id)\n    return data\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.p_idx","title":"p_idx","text":"<pre><code>p_idx(p_idx: int | str)\n</code></pre> <p>Setter for particle index.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>@SPHGalaxy.p_idx.setter\ndef p_idx(self, p_idx: int | str):\n    \"\"\"Setter for particle index.\"\"\"\n    SPHGalaxy.p_idx.fset(self, p_idx)\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.TNGGalaxy.subhalo_list","title":"subhalo_list  <code>staticmethod</code>","text":"<pre><code>subhalo_list(\n    base_path: str,\n    snapshot: int,\n    filtered: bool = True,\n    verbose: bool = False,\n) -&gt; NDArray\n</code></pre> <p>Pull a list of subhalo IDs from the snapshot's FOF group catalog.</p> <p>Note: the indices of the list are halo IDs.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Base path to the Illustris(TNG) snapshots.</p> required <code>snapshot</code> <code>int</code> <p>Snapshot ID {0-99}.</p> required <code>filtered</code> <code>bool</code> <p>If True, negative subhalo IDs are filtered out.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, print out results to the command line.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | np.ndarray</code> <p>a list of subhalo i.e. galaxy IDs.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>@staticmethod\ndef subhalo_list(\n    base_path: str,\n    snapshot: int,\n    filtered: bool = True,\n    verbose: bool = False,\n) -&gt; NDArray:\n    \"\"\"Pull a list of subhalo IDs from the snapshot's FOF group catalog.\n\n    Note: the indices of the list are halo IDs.\n\n    Args:\n        base_path: Base path to the Illustris(TNG) snapshots.\n        snapshot: Snapshot ID {0-99}.\n        filtered: If True, negative subhalo IDs are filtered out.\n        verbose: If True, print out results to the command line.\n\n    Returns:\n        (list | np.ndarray): a list of subhalo i.e. galaxy IDs.\n    \"\"\"\n    kwargs = {\"fields\": [\"GroupFirstSub\"]}\n    if verbose:\n        print(f\"Searching group catalog: snapshot {snapshot}\")\n    galaxy_list = tng.groupcat.load_halos(base_path, snapshot, as_array=True, **kwargs)\n    galaxy_list = galaxy_list[galaxy_list &gt;= 0] if filtered else galaxy_list\n    if verbose:\n        N_g = galaxy_list.max()\n        N_g += 0 in galaxy_list\n        print(f\"Found {N_g} groups in catalog: snapshot {snapshot}\")\n    return galaxy_list\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.indices_within_box","title":"indices_within_box","text":"<pre><code>indices_within_box(\n    pos: np.ndarray | au.Quantity,\n    center: list | np.ndarray | au.Quantity,\n    radius: float | au.Quantity = None,\n    fraction: float = 1.0,\n    verbose: bool = False,\n) -&gt; tuple[au.Quantity, list[au.Quantity]]\n</code></pre> <p>Get particle indices within a box of given radius from the centre, e.g. half-mass radius.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>np.ndarray | au.Quantity</code> <p>Particle positions to be filtered.</p> required <code>center</code> <code>list | np.ndarray | au.Quantity</code> <p>Center position of the cube.</p> required <code>radius</code> <code>float | au.Quantity</code> <p>Radius, i.e. half-side of the cube.</p> <code>None</code> <code>fraction</code> <code>float</code> <p>Box fraction for the default radius if not given.</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>If True, print status updates to command line.</p> <code>False</code> <p>Returns:</p> Type Description <code>(au.Quantity, list[au.Quantity])</code> <p>Indices of the filtered particle positions and their 3D extent.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def indices_within_box(\n    pos: np.ndarray | au.Quantity,\n    center: list | np.ndarray | au.Quantity,\n    radius: float | au.Quantity = None,\n    fraction: float = 1.0,\n    verbose: bool = False,\n) -&gt; tuple[au.Quantity, list[au.Quantity]]:\n    \"\"\"Get particle indices within a box of given radius from the centre, e.g. half-mass radius.\n\n    Args:\n        pos: Particle positions to be filtered.\n        center: Center position of the cube.\n        radius: Radius, i.e. half-side of the cube.\n        fraction: Box fraction for the default radius if not given.\n        verbose: If True, print status updates to command line.\n\n    Returns:\n        (au.Quantity, list[au.Quantity]):\n          Indices of the filtered particle positions and their 3D extent.\n    \"\"\"\n    pos_extent = (\n        pos[:, 0].max() - pos[:, 0].min(),\n        pos[:, 1].max() - pos[:, 1].min(),\n        pos[:, 2].max() - pos[:, 2].min(),\n    )\n    w = max(pos_extent)\n    if verbose:\n        print(f\"Box extent:  {pos_extent[0]}   {pos_extent[1]}   {pos_extent[2]}\")\n    if radius is None:\n        radius = 0.25 * fraction * w\n    else:\n        radius *= fraction\n    if verbose:\n        print(f\"Radius: {radius}\")\n    xmin, xmax = center[0] - radius, center[0] + radius\n    ymin, ymax = center[1] - radius, center[1] + radius\n    zmin, zmax = center[2] - radius, center[2] + radius\n    if verbose:\n        print(f\"Extent: {xmax - xmin}   {ymax - ymin}   {zmax - zmin}\")\n    indices = np.where(\n        (pos[:, 0] &gt; xmin)\n        &amp; (pos[:, 0] &lt; xmax)\n        &amp; (pos[:, 1] &gt; ymin)\n        &amp; (pos[:, 1] &lt; ymax)\n        &amp; (pos[:, 2] &gt; zmin)\n        &amp; (pos[:, 2] &lt; zmax)\n    )[0]\n    if verbose:\n        print(f\"Selected particles: {indices.shape[0]:,} / {pos.shape[0]:,}\")\n    return indices, [xmin, ymin, zmin, xmax, ymax, zmax]\n</code></pre>"},{"location":"reference/skais_mapper/simobjects/#skais_mapper.simobjects.strip_ap_units","title":"strip_ap_units","text":"<pre><code>strip_ap_units(\n    *args,\n    mask: list | None = None,\n    units: list[au.Unit] | None = None,\n    dtype: Any = np.float32,\n) -&gt; list\n</code></pre> <p>Remove astropy units from data arrays or scalars.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Data arrays or scalars with astropy units.</p> <code>()</code> <code>mask</code> <code>list | None</code> <p>Mask for the data arrays.</p> <code>None</code> <code>units</code> <code>list[au.Unit] | None</code> <p>Astropy units to be stripped.</p> <code>None</code> <code>dtype</code> <code>Any</code> <p>Data type of the stripped data array.</p> <code>np.float32</code> <p>Returns:</p> Type Description <code>list[np.ndarray]</code> <p>Of astropy units stripped data arrays or scalars.</p> Source code in <code>skais_mapper/simobjects.py</code> <pre><code>def strip_ap_units(\n    *args,\n    mask: list | None = None,\n    units: list[au.Unit] | None = None,\n    dtype: Any = np.float32,\n) -&gt; list:\n    \"\"\"Remove astropy units from data arrays or scalars.\n\n    Args:\n        args: Data arrays or scalars with astropy units.\n        mask: Mask for the data arrays.\n        units: Astropy units to be stripped.\n        dtype: Data type of the stripped data array.\n\n    Returns:\n        (list[np.ndarray]): Of astropy units stripped data arrays or scalars.\n    \"\"\"\n    arg_ls = list(args)\n    for i, arg in enumerate(arg_ls):\n        if units is not None:\n            for u in units:\n                if arg_ls[i].unit.is_equivalent(u):\n                    arg_ls[i] = arg_ls[i].to(u)\n        arg_ls[i] = arg_ls[i].value\n        if isinstance(arg_ls[i], np.ndarray):\n            if mask is not None:\n                arg_ls[i] = arg_ls[i][mask].astype(dtype)\n    return arg_ls\n</code></pre>"},{"location":"reference/skais_mapper/utils/","title":"skais_mapper.utils","text":""},{"location":"reference/skais_mapper/utils/#skais_mapper.utils","title":"skais_mapper.utils","text":"<p>All utility functions can be imported from here.</p> <p>Modules:</p> Name Description <code>colors</code> <p>Color module for more beautiful plots.</p> <code>config</code> <p>Configuration and runtime utility functions.</p> <code>helper</code> <p>Generic helper functions and other stuff.</p> <code>primes</code> <p>Functions for checking and computing prime numbers.</p> <p>Classes:</p> Name Description <code>SkaisColorMaps</code> <p>An assortment of linearly interpolated colormaps based on 4+ colors each.</p> <code>SkaisColors</code> <p>An assortment of colors and palettes.</p> <p>Functions:</p> Name Description <code>alias_kw</code> <p>Decorator for aliasing a keyword argument in a function.</p> <code>compress_encode</code> <p>Compress and encode a string for shorter representations.</p> <code>current_time</code> <p>Get current time as string.</p> <code>extract_decode</code> <p>Decompress and decode a short representation string.</p> <code>get_run_id</code> <p>Fetch a run-specific identifier.</p> <code>next_prime</code> <p>Next prime strictly larger than n.</p> <code>set_run_id</code> <p>Set the run-specific identifier.</p>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColorMaps","title":"SkaisColorMaps","text":"<p>An assortment of linearly interpolated colormaps based on 4+ colors each.</p> <p>Methods:</p> Name Description <code>gen</code> <p>Generate colormaps.</p> <code>palette</code> <p>Return a palette of a colormap with N linearly interpolated color points.</p> <code>plot_gradients</code> <p>Plot all color-map gradients.</p> <code>random</code> <p>Choose a random color map.</p> <code>register_all</code> <p>Register colormaps with matplotlib.</p> <code>reverse</code> <p>Reverse the specified colormap.</p>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColorMaps.gen","title":"gen  <code>classmethod</code>","text":"<pre><code>gen()\n</code></pre> <p>Generate colormaps.</p> <p>Returns:</p> Type Description <code>mpl.colors.LinearSegmentedColormap object</code> <p>colormap generated from custom list</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef gen(cls):\n    \"\"\"Generate colormaps.\n\n    Returns:\n        (mpl.colors.LinearSegmentedColormap object): colormap generated from custom list\n    \"\"\"\n    yield from cls.aslist\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColorMaps.palette","title":"palette  <code>classmethod</code>","text":"<pre><code>palette(cmap_name: str, N: int)\n</code></pre> <p>Return a palette of a colormap with N linearly interpolated color points.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>name of the colormap</p> required <code>N</code> <code>int</code> <p>number of colors in the palette</p> required Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef palette(cls, cmap_name: str, N: int):\n    \"\"\"Return a palette of a colormap with N linearly interpolated color points.\n\n    Args:\n        cmap_name: name of the colormap\n        N: number of colors in the palette\n    \"\"\"\n    vals = np.linspace(0, 1, N)\n    cmap = cls.__dict__[cmap_name]\n    rgbas = cmap(vals)\n    return [to_hex(rgba, keep_alpha=False) for rgba in rgbas]\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColorMaps.plot_gradients","title":"plot_gradients  <code>classmethod</code>","text":"<pre><code>plot_gradients(savefig: bool = False)\n</code></pre> <p>Plot all color-map gradients.</p> <p>Parameters:</p> Name Type Description Default <code>savefig</code> <code>bool</code> <p>save figure as palettes.png</p> <code>False</code> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef plot_gradients(cls, savefig: bool = False):\n    \"\"\"Plot all color-map gradients.\n\n    Args:\n        savefig (bool): save figure as palettes.png\n    \"\"\"\n    gradient = np.linspace(0, 1, 256)\n    gradient = np.vstack((gradient, gradient))\n    fig, axes = plt.subplots(nrows=SkaisColorMaps.N)\n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)\n    for ax, cmap in zip(axes, cls.aslist):\n        ax.imshow(gradient, aspect=\"auto\", cmap=cmap)\n        pos = list(ax.get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2.0\n        fig.text(x_text, y_text, cmap.name, va=\"center\", ha=\"right\", fontsize=10)\n    for ax in axes:\n        ax.set_axis_off()\n    if savefig:\n        plt.savefig(\"palette.png\")\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColorMaps.random","title":"random  <code>classmethod</code>","text":"<pre><code>random() -&gt; LinearSegmentedColormap\n</code></pre> <p>Choose a random color map.</p> <p>Returns:</p> Name Type Description <code>cmap</code> <code>LinearSegmentedColormap</code> <p>random colormap from custom list</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef random(cls) -&gt; LinearSegmentedColormap:\n    \"\"\"Choose a random color map.\n\n    Returns:\n        cmap: random colormap from custom list\n    \"\"\"\n    return random.choice(cls.aslist)\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColorMaps.register_all","title":"register_all  <code>staticmethod</code>","text":"<pre><code>register_all(verbose: bool = False)\n</code></pre> <p>Register colormaps with matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print information to command line</p> <code>False</code> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@staticmethod\ndef register_all(verbose: bool = False):\n    \"\"\"Register colormaps with matplotlib.\n\n    Args:\n        verbose (bool): If True, print information to command line\n    \"\"\"\n    for g in SkaisColorMaps.aslist:\n        if verbose:\n            print(g.name)\n        if g.name not in mpl.colormaps:\n            mpl.colormaps.register(name=g.name, cmap=g)\n        if f\"skais_{g.name}\" not in mpl.colormaps:\n            mpl.colormaps.register(name=f\"skais_{g.name}\", cmap=g)\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColorMaps.reverse","title":"reverse  <code>classmethod</code>","text":"<pre><code>reverse(\n    cmap: Colormap,\n    set_bad: str = None,\n    set_under: str = None,\n    set_over: str = None,\n) -&gt; LinearSegmentedColormap\n</code></pre> <p>Reverse the specified colormap.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>mpl.colors.LinearSegmentedColormap object</code> <p>colormap to be reversed</p> required <code>set_bad</code> <code>str</code> <p>set colormaps bad values to a different color</p> <code>None</code> <code>set_under</code> <code>str</code> <p>set colormaps under values to a different color</p> <code>None</code> <code>set_over</code> <code>str</code> <p>set colormaps over values to a different color</p> <code>None</code> <p>Returns:</p> Type Description <code>mpl.colors.LinearSegmentedColormap object</code> <p>reversed colormap</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef reverse(\n    cls, cmap: Colormap, set_bad: str = None, set_under: str = None, set_over: str = None\n) -&gt; LinearSegmentedColormap:\n    \"\"\"Reverse the specified colormap.\n\n    Args:\n        cmap (mpl.colors.LinearSegmentedColormap object): colormap to be reversed\n        set_bad (str): set colormaps bad values to a different color\n        set_under (str): set colormaps under values to a different color\n        set_over (str): set colormaps over values to a different color\n\n    Returns:\n        (mpl.colors.LinearSegmentedColormap object): reversed colormap\n    \"\"\"\n    reverse = []\n    k = []\n\n    for key in cmap._segmentdata:\n        k.append(key)\n\n        channel = cmap._segmentdata[key]\n        data = []\n\n        for t in channel:\n            data.append((1 - t[0], t[2], t[1]))\n        reverse.append(sorted(data))\n\n    linear_l = dict(zip(k, reverse))\n    rcmap = LinearSegmentedColormap(f\"{cmap.name}_r\", linear_l)\n    if set_bad is not None:\n        rcmap.set_bad(set_bad)\n    if set_under is not None:\n        rcmap.set_over(set_under)\n    if set_over is not None:\n        rcmap.set_over(set_over)\n    return rcmap\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColors","title":"SkaisColors","text":"<p>An assortment of colors and palettes.</p> <p>Methods:</p> Name Description <code>cmap_from_color</code> <p>Create a colormap from a single color.</p>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.SkaisColors.cmap_from_color","title":"cmap_from_color  <code>classmethod</code>","text":"<pre><code>cmap_from_color(\n    color_str: str, secondary_color: str | None = None\n) -&gt; LinearSegmentedColormap\n</code></pre> <p>Create a colormap from a single color.</p> <p>Parameters:</p> Name Type Description Default <code>color_str</code> <code>str</code> <p>color string of the class color</p> required <code>secondary_color</code> <code>str | None</code> <p>color into which the color changes in the colormap</p> <code>None</code> <p>Returns:</p> Type Description <code>mpl.colors.LinearSegmentedColormap object</code> <p>reversed colormap</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef cmap_from_color(\n    cls,\n    color_str: str,\n    secondary_color: str | None = None,\n) -&gt; LinearSegmentedColormap:\n    \"\"\"Create a colormap from a single color.\n\n    Args:\n        color_str: color string of the class color\n        secondary_color: color into which the color changes in the colormap\n\n    Returns:\n        (mpl.colors.LinearSegmentedColormap object): reversed colormap\n    \"\"\"\n    if color_str in cls.__dict__:\n        color = cls.__dict__[color_str]\n    else:\n        color = color_str\n    if secondary_color in cls.__dict__:\n        secondary_color = cls.__dict__[secondary_color]\n    elif secondary_color is None:\n        secondary_color = color_variant(color, shift=125)\n    cmap = LinearSegmentedColormap.from_list(\"Skais\" + color_str, [secondary_color, color])\n    return cmap\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.alias_kw","title":"alias_kw","text":"<pre><code>alias_kw(key: str, alias: str) -&gt; Callable\n</code></pre> <p>Decorator for aliasing a keyword argument in a function.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of keyword argument in function to alias</p> required <code>alias</code> <code>str</code> <p>Alias that can be used for this keyword argument</p> required Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def alias_kw(key: str, alias: str) -&gt; Callable:\n    \"\"\"Decorator for aliasing a keyword argument in a function.\n\n    Args:\n        key: Name of keyword argument in function to alias\n        alias: Alias that can be used for this keyword argument\n    \"\"\"\n    def decorator(func: Callable):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            alias_value = kwargs.get(alias)\n            if alias_value:\n                kwargs[key] = alias_value\n            if alias in kwargs:\n                del kwargs[alias]\n            result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.compress_encode","title":"compress_encode","text":"<pre><code>compress_encode(string: str) -&gt; str\n</code></pre> <p>Compress and encode a string for shorter representations.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String to be encoded.</p> required Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def compress_encode(string: str) -&gt; str:\n    \"\"\"Compress and encode a string for shorter representations.\n\n    Args:\n        string: String to be encoded.\n    \"\"\"\n    compressed_data = lzma.compress(string.encode(\"utf-8\"))\n    encoded_data = base64.b64encode(compressed_data)\n    return encoded_data.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.current_time","title":"current_time","text":"<pre><code>current_time(\n    date_only: bool = True,\n    as_str: bool = True,\n    no_delim: bool = True,\n) -&gt; datetime.datetime | str\n</code></pre> <p>Get current time as string.</p> <p>Parameters:</p> Name Type Description Default <code>date_only</code> <code>bool</code> <p>If True, only the date is returned.</p> <code>True</code> <code>as_str</code> <code>bool</code> <p>If True, a string is returned instead of a datetime object.</p> <code>True</code> <code>no_delim</code> <code>bool</code> <p>If a string is returned, remove the standard delimiters.</p> <code>True</code> Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def current_time(\n    date_only: bool = True, as_str: bool = True, no_delim: bool = True\n) -&gt; datetime.datetime | str:\n    \"\"\"Get current time as string.\n\n    Args:\n        date_only: If True, only the date is returned.\n        as_str: If True, a string is returned instead of a datetime object.\n        no_delim: If a string is returned, remove the standard delimiters.\n    \"\"\"\n    t = datetime.datetime.now()\n    if date_only:\n        t = t.date()\n    if as_str:\n        t = str(t)\n        if no_delim:\n            t = t.replace(\"-\", \"\")\n    return t\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.extract_decode","title":"extract_decode","text":"<pre><code>extract_decode(string: str) -&gt; str\n</code></pre> <p>Decompress and decode a short representation string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>Compressed base64 string to be decoded.</p> required Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def extract_decode(string: str) -&gt; str:\n    \"\"\"Decompress and decode a short representation string.\n\n    Args:\n        string: Compressed base64 string to be decoded.\n    \"\"\"\n    compressed_data = base64.b64decode(string)\n    original_data = lzma.decompress(compressed_data)\n    return original_data.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.get_run_id","title":"get_run_id","text":"<pre><code>get_run_id(length: int = 8) -&gt; str\n</code></pre> <p>Fetch a run-specific identifier.</p> Source code in <code>skais_mapper/utils/config.py</code> <pre><code>def get_run_id(\n    length: int = 8,\n) -&gt; str:\n    \"\"\"Fetch a run-specific identifier.\"\"\"\n    return str(skais_mapper.RUN_UID).replace(\"-\", \"\")[:length]\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.next_prime","title":"next_prime","text":"<pre><code>next_prime(n: int) -&gt; int\n</code></pre> <p>Next prime strictly larger than n.</p> Source code in <code>skais_mapper/utils/primes.py</code> <pre><code>def next_prime(n: int) -&gt; int:\n    \"\"\"Next prime strictly larger than n.\"\"\"\n    if n &lt; 2:\n        return 2\n    # first odd larger than n\n    n = (n + 1) | 1\n    if n &lt; 212:\n        while True:\n            if n in SMALL_PRIMES:\n                return n\n            n += 2\n\n    # find our position in the sieve rotation via binary search\n    x = int(n % 210)\n    s = 0\n    e = 47\n    m = 24\n    while m != e:\n        if SIEVE_INDICES[m] &lt; x:\n            s = m\n            m = (s + e + 1) &gt;&gt; 1\n        else:\n            e = m\n            m = (s + e) &gt;&gt; 1\n\n    i = int(n + (SIEVE_INDICES[m] - x))\n    # adjust offsets\n    offs = SIEVE_OFFSETS[m:] + SIEVE_OFFSETS[:m]\n    while True:\n        for o in offs:\n            if is_prime(i):\n                return i\n            i += o\n</code></pre>"},{"location":"reference/skais_mapper/utils/#skais_mapper.utils.set_run_id","title":"set_run_id","text":"<pre><code>set_run_id(run_id: uuid.UUID | str | None = None)\n</code></pre> <p>Set the run-specific identifier.</p> Source code in <code>skais_mapper/utils/config.py</code> <pre><code>def set_run_id(run_id: uuid.UUID | str | None = None):\n    \"\"\"Set the run-specific identifier.\"\"\"\n    if run_id is None:\n        run_id = uuid.uuid4()\n    if not isinstance(run_id, uuid.UUID):\n        run_id = uuid.UUID(run_id)\n    skais_mapper.RUN_UID = run_id\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/","title":"skais_mapper.utils.colors","text":""},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors","title":"skais_mapper.utils.colors","text":"<p>Color module for more beautiful plots.</p> <p>Classes:</p> Name Description <code>SkaisColorMaps</code> <p>An assortment of linearly interpolated colormaps based on 4+ colors each.</p> <code>SkaisColors</code> <p>An assortment of colors and palettes.</p> <p>Functions:</p> Name Description <code>color_variant</code> <p>Takes a color in hex code and produces a lighter or darker shift variant.</p>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.ReNormColormapAdaptor","title":"ReNormColormapAdaptor","text":"<pre><code>ReNormColormapAdaptor(\n    base,\n    cmap_norm: Normalize,\n    orig_norm: Normalize | None = None,\n)\n</code></pre> <p>               Bases: <code>Colormap</code></p> <p>Adaptor for re-normalizing color mappable.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Re-normalise the values before applying the colormap.</p> <code>reversed</code> <p>Abstract dummy method.</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>def __init__(self, base, cmap_norm: Normalize, orig_norm: Normalize | None = None):\n    if orig_norm is None:\n        if isinstance(base, ScalarMappable):\n            orig_norm = base.norm\n            base = base.cmap\n        else:\n            orig_norm = Normalize(0, 1)\n    self._base = base\n    if isinstance(cmap_norm, type(Normalize)) and issubclass(cmap_norm, Normalize):\n        # a class was provided instead of an instance. create an instance\n        # with the same limits.\n        cmap_norm = cmap_norm(orig_norm.vmin, orig_norm.vmax)\n    self._cmap_norm = cmap_norm\n    self._orig_norm = orig_norm\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.ReNormColormapAdaptor.__call__","title":"__call__","text":"<pre><code>__call__(X, **kwargs)\n</code></pre> <p>Re-normalise the values before applying the colormap.</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>def __call__(self, X, **kwargs):\n    \"\"\"Re-normalise the values before applying the colormap.\"\"\"\n    return self._base(self._cmap_norm(self._orig_norm.inverse(X)), **kwargs)\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.ReNormColormapAdaptor.reversed","title":"reversed","text":"<pre><code>reversed(*args, **kwargs)\n</code></pre> <p>Abstract dummy method.</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>def reversed(self, *args, **kwargs):\n    \"\"\"Abstract dummy method.\"\"\"\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColorMaps","title":"SkaisColorMaps","text":"<p>An assortment of linearly interpolated colormaps based on 4+ colors each.</p> <p>Methods:</p> Name Description <code>gen</code> <p>Generate colormaps.</p> <code>palette</code> <p>Return a palette of a colormap with N linearly interpolated color points.</p> <code>plot_gradients</code> <p>Plot all color-map gradients.</p> <code>random</code> <p>Choose a random color map.</p> <code>register_all</code> <p>Register colormaps with matplotlib.</p> <code>reverse</code> <p>Reverse the specified colormap.</p>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColorMaps.gen","title":"gen  <code>classmethod</code>","text":"<pre><code>gen()\n</code></pre> <p>Generate colormaps.</p> <p>Returns:</p> Type Description <code>mpl.colors.LinearSegmentedColormap object</code> <p>colormap generated from custom list</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef gen(cls):\n    \"\"\"Generate colormaps.\n\n    Returns:\n        (mpl.colors.LinearSegmentedColormap object): colormap generated from custom list\n    \"\"\"\n    yield from cls.aslist\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColorMaps.palette","title":"palette  <code>classmethod</code>","text":"<pre><code>palette(cmap_name: str, N: int)\n</code></pre> <p>Return a palette of a colormap with N linearly interpolated color points.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>name of the colormap</p> required <code>N</code> <code>int</code> <p>number of colors in the palette</p> required Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef palette(cls, cmap_name: str, N: int):\n    \"\"\"Return a palette of a colormap with N linearly interpolated color points.\n\n    Args:\n        cmap_name: name of the colormap\n        N: number of colors in the palette\n    \"\"\"\n    vals = np.linspace(0, 1, N)\n    cmap = cls.__dict__[cmap_name]\n    rgbas = cmap(vals)\n    return [to_hex(rgba, keep_alpha=False) for rgba in rgbas]\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColorMaps.plot_gradients","title":"plot_gradients  <code>classmethod</code>","text":"<pre><code>plot_gradients(savefig: bool = False)\n</code></pre> <p>Plot all color-map gradients.</p> <p>Parameters:</p> Name Type Description Default <code>savefig</code> <code>bool</code> <p>save figure as palettes.png</p> <code>False</code> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef plot_gradients(cls, savefig: bool = False):\n    \"\"\"Plot all color-map gradients.\n\n    Args:\n        savefig (bool): save figure as palettes.png\n    \"\"\"\n    gradient = np.linspace(0, 1, 256)\n    gradient = np.vstack((gradient, gradient))\n    fig, axes = plt.subplots(nrows=SkaisColorMaps.N)\n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)\n    for ax, cmap in zip(axes, cls.aslist):\n        ax.imshow(gradient, aspect=\"auto\", cmap=cmap)\n        pos = list(ax.get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2.0\n        fig.text(x_text, y_text, cmap.name, va=\"center\", ha=\"right\", fontsize=10)\n    for ax in axes:\n        ax.set_axis_off()\n    if savefig:\n        plt.savefig(\"palette.png\")\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColorMaps.random","title":"random  <code>classmethod</code>","text":"<pre><code>random() -&gt; LinearSegmentedColormap\n</code></pre> <p>Choose a random color map.</p> <p>Returns:</p> Name Type Description <code>cmap</code> <code>LinearSegmentedColormap</code> <p>random colormap from custom list</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef random(cls) -&gt; LinearSegmentedColormap:\n    \"\"\"Choose a random color map.\n\n    Returns:\n        cmap: random colormap from custom list\n    \"\"\"\n    return random.choice(cls.aslist)\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColorMaps.register_all","title":"register_all  <code>staticmethod</code>","text":"<pre><code>register_all(verbose: bool = False)\n</code></pre> <p>Register colormaps with matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print information to command line</p> <code>False</code> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@staticmethod\ndef register_all(verbose: bool = False):\n    \"\"\"Register colormaps with matplotlib.\n\n    Args:\n        verbose (bool): If True, print information to command line\n    \"\"\"\n    for g in SkaisColorMaps.aslist:\n        if verbose:\n            print(g.name)\n        if g.name not in mpl.colormaps:\n            mpl.colormaps.register(name=g.name, cmap=g)\n        if f\"skais_{g.name}\" not in mpl.colormaps:\n            mpl.colormaps.register(name=f\"skais_{g.name}\", cmap=g)\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColorMaps.reverse","title":"reverse  <code>classmethod</code>","text":"<pre><code>reverse(\n    cmap: Colormap,\n    set_bad: str = None,\n    set_under: str = None,\n    set_over: str = None,\n) -&gt; LinearSegmentedColormap\n</code></pre> <p>Reverse the specified colormap.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>mpl.colors.LinearSegmentedColormap object</code> <p>colormap to be reversed</p> required <code>set_bad</code> <code>str</code> <p>set colormaps bad values to a different color</p> <code>None</code> <code>set_under</code> <code>str</code> <p>set colormaps under values to a different color</p> <code>None</code> <code>set_over</code> <code>str</code> <p>set colormaps over values to a different color</p> <code>None</code> <p>Returns:</p> Type Description <code>mpl.colors.LinearSegmentedColormap object</code> <p>reversed colormap</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef reverse(\n    cls, cmap: Colormap, set_bad: str = None, set_under: str = None, set_over: str = None\n) -&gt; LinearSegmentedColormap:\n    \"\"\"Reverse the specified colormap.\n\n    Args:\n        cmap (mpl.colors.LinearSegmentedColormap object): colormap to be reversed\n        set_bad (str): set colormaps bad values to a different color\n        set_under (str): set colormaps under values to a different color\n        set_over (str): set colormaps over values to a different color\n\n    Returns:\n        (mpl.colors.LinearSegmentedColormap object): reversed colormap\n    \"\"\"\n    reverse = []\n    k = []\n\n    for key in cmap._segmentdata:\n        k.append(key)\n\n        channel = cmap._segmentdata[key]\n        data = []\n\n        for t in channel:\n            data.append((1 - t[0], t[2], t[1]))\n        reverse.append(sorted(data))\n\n    linear_l = dict(zip(k, reverse))\n    rcmap = LinearSegmentedColormap(f\"{cmap.name}_r\", linear_l)\n    if set_bad is not None:\n        rcmap.set_bad(set_bad)\n    if set_under is not None:\n        rcmap.set_over(set_under)\n    if set_over is not None:\n        rcmap.set_over(set_over)\n    return rcmap\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColors","title":"SkaisColors","text":"<p>An assortment of colors and palettes.</p> <p>Methods:</p> Name Description <code>cmap_from_color</code> <p>Create a colormap from a single color.</p>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.SkaisColors.cmap_from_color","title":"cmap_from_color  <code>classmethod</code>","text":"<pre><code>cmap_from_color(\n    color_str: str, secondary_color: str | None = None\n) -&gt; LinearSegmentedColormap\n</code></pre> <p>Create a colormap from a single color.</p> <p>Parameters:</p> Name Type Description Default <code>color_str</code> <code>str</code> <p>color string of the class color</p> required <code>secondary_color</code> <code>str | None</code> <p>color into which the color changes in the colormap</p> <code>None</code> <p>Returns:</p> Type Description <code>mpl.colors.LinearSegmentedColormap object</code> <p>reversed colormap</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>@classmethod\ndef cmap_from_color(\n    cls,\n    color_str: str,\n    secondary_color: str | None = None,\n) -&gt; LinearSegmentedColormap:\n    \"\"\"Create a colormap from a single color.\n\n    Args:\n        color_str: color string of the class color\n        secondary_color: color into which the color changes in the colormap\n\n    Returns:\n        (mpl.colors.LinearSegmentedColormap object): reversed colormap\n    \"\"\"\n    if color_str in cls.__dict__:\n        color = cls.__dict__[color_str]\n    else:\n        color = color_str\n    if secondary_color in cls.__dict__:\n        secondary_color = cls.__dict__[secondary_color]\n    elif secondary_color is None:\n        secondary_color = color_variant(color, shift=125)\n    cmap = LinearSegmentedColormap.from_list(\"Skais\" + color_str, [secondary_color, color])\n    return cmap\n</code></pre>"},{"location":"reference/skais_mapper/utils/colors/#skais_mapper.utils.colors.color_variant","title":"color_variant","text":"<pre><code>color_variant(hex_color: str, shift: int = 10) -&gt; str\n</code></pre> <p>Takes a color in hex code and produces a lighter or darker shift variant.</p> <p>Parameters:</p> Name Type Description Default <code>hex_color</code> <code>str</code> <p>formatted as '#' + rgb hex string of length 6</p> required <code>shift</code> <code>int</code> <p>decimal shift of the rgb hex string</p> <code>10</code> <p>Returns:</p> Name Type Description <code>variant</code> <code>str</code> <p>formatted as '#' + rgb hex string of length 6</p> Source code in <code>skais_mapper/utils/colors.py</code> <pre><code>def color_variant(hex_color: str, shift: int = 10) -&gt; str:\n    \"\"\"Takes a color in hex code and produces a lighter or darker shift variant.\n\n    Args:\n        hex_color (str): formatted as '#' + rgb hex string of length 6\n        shift (int): decimal shift of the rgb hex string\n\n    Returns:\n        variant (str): formatted as '#' + rgb hex string of length 6\n    \"\"\"\n    if len(hex_color) != 7:\n        message = \"Passed {} to color_variant(), needs to be in hex format.\"\n        raise ValueError(message.format(hex_color))\n    rgb_hex = [hex_color[x : x + 2] for x in [1, 3, 5]]\n    new_rgb_int = [int(hex_value, 16) + shift for hex_value in rgb_hex]\n    # limit to interval 0 and 255\n    new_rgb_int = [min([255, max([0, i])]) for i in new_rgb_int]\n    # hex() produces \"0x88\", we want the last two digits\n    return \"#\" + \"\".join([hex(i)[2:] if i else \"00\" for i in new_rgb_int])\n</code></pre>"},{"location":"reference/skais_mapper/utils/config/","title":"skais_mapper.utils.config","text":""},{"location":"reference/skais_mapper/utils/config/#skais_mapper.utils.config","title":"skais_mapper.utils.config","text":"<p>Configuration and runtime utility functions.</p> <p>Functions:</p> Name Description <code>get_run_id</code> <p>Fetch a run-specific identifier.</p> <code>set_run_id</code> <p>Set the run-specific identifier.</p>"},{"location":"reference/skais_mapper/utils/config/#skais_mapper.utils.config.get_run_id","title":"get_run_id","text":"<pre><code>get_run_id(length: int = 8) -&gt; str\n</code></pre> <p>Fetch a run-specific identifier.</p> Source code in <code>skais_mapper/utils/config.py</code> <pre><code>def get_run_id(\n    length: int = 8,\n) -&gt; str:\n    \"\"\"Fetch a run-specific identifier.\"\"\"\n    return str(skais_mapper.RUN_UID).replace(\"-\", \"\")[:length]\n</code></pre>"},{"location":"reference/skais_mapper/utils/config/#skais_mapper.utils.config.set_run_id","title":"set_run_id","text":"<pre><code>set_run_id(run_id: uuid.UUID | str | None = None)\n</code></pre> <p>Set the run-specific identifier.</p> Source code in <code>skais_mapper/utils/config.py</code> <pre><code>def set_run_id(run_id: uuid.UUID | str | None = None):\n    \"\"\"Set the run-specific identifier.\"\"\"\n    if run_id is None:\n        run_id = uuid.uuid4()\n    if not isinstance(run_id, uuid.UUID):\n        run_id = uuid.UUID(run_id)\n    skais_mapper.RUN_UID = run_id\n</code></pre>"},{"location":"reference/skais_mapper/utils/helper/","title":"skais_mapper.utils.helper","text":""},{"location":"reference/skais_mapper/utils/helper/#skais_mapper.utils.helper","title":"skais_mapper.utils.helper","text":"<p>Generic helper functions and other stuff.</p> <p>Functions:</p> Name Description <code>alias_kw</code> <p>Decorator for aliasing a keyword argument in a function.</p> <code>compress_encode</code> <p>Compress and encode a string for shorter representations.</p> <code>current_time</code> <p>Get current time as string.</p> <code>extract_decode</code> <p>Decompress and decode a short representation string.</p>"},{"location":"reference/skais_mapper/utils/helper/#skais_mapper.utils.helper.alias_kw","title":"alias_kw","text":"<pre><code>alias_kw(key: str, alias: str) -&gt; Callable\n</code></pre> <p>Decorator for aliasing a keyword argument in a function.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of keyword argument in function to alias</p> required <code>alias</code> <code>str</code> <p>Alias that can be used for this keyword argument</p> required Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def alias_kw(key: str, alias: str) -&gt; Callable:\n    \"\"\"Decorator for aliasing a keyword argument in a function.\n\n    Args:\n        key: Name of keyword argument in function to alias\n        alias: Alias that can be used for this keyword argument\n    \"\"\"\n    def decorator(func: Callable):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            alias_value = kwargs.get(alias)\n            if alias_value:\n                kwargs[key] = alias_value\n            if alias in kwargs:\n                del kwargs[alias]\n            result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"reference/skais_mapper/utils/helper/#skais_mapper.utils.helper.compress_encode","title":"compress_encode","text":"<pre><code>compress_encode(string: str) -&gt; str\n</code></pre> <p>Compress and encode a string for shorter representations.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String to be encoded.</p> required Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def compress_encode(string: str) -&gt; str:\n    \"\"\"Compress and encode a string for shorter representations.\n\n    Args:\n        string: String to be encoded.\n    \"\"\"\n    compressed_data = lzma.compress(string.encode(\"utf-8\"))\n    encoded_data = base64.b64encode(compressed_data)\n    return encoded_data.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/skais_mapper/utils/helper/#skais_mapper.utils.helper.current_time","title":"current_time","text":"<pre><code>current_time(\n    date_only: bool = True,\n    as_str: bool = True,\n    no_delim: bool = True,\n) -&gt; datetime.datetime | str\n</code></pre> <p>Get current time as string.</p> <p>Parameters:</p> Name Type Description Default <code>date_only</code> <code>bool</code> <p>If True, only the date is returned.</p> <code>True</code> <code>as_str</code> <code>bool</code> <p>If True, a string is returned instead of a datetime object.</p> <code>True</code> <code>no_delim</code> <code>bool</code> <p>If a string is returned, remove the standard delimiters.</p> <code>True</code> Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def current_time(\n    date_only: bool = True, as_str: bool = True, no_delim: bool = True\n) -&gt; datetime.datetime | str:\n    \"\"\"Get current time as string.\n\n    Args:\n        date_only: If True, only the date is returned.\n        as_str: If True, a string is returned instead of a datetime object.\n        no_delim: If a string is returned, remove the standard delimiters.\n    \"\"\"\n    t = datetime.datetime.now()\n    if date_only:\n        t = t.date()\n    if as_str:\n        t = str(t)\n        if no_delim:\n            t = t.replace(\"-\", \"\")\n    return t\n</code></pre>"},{"location":"reference/skais_mapper/utils/helper/#skais_mapper.utils.helper.extract_decode","title":"extract_decode","text":"<pre><code>extract_decode(string: str) -&gt; str\n</code></pre> <p>Decompress and decode a short representation string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>Compressed base64 string to be decoded.</p> required Source code in <code>skais_mapper/utils/helper.py</code> <pre><code>def extract_decode(string: str) -&gt; str:\n    \"\"\"Decompress and decode a short representation string.\n\n    Args:\n        string: Compressed base64 string to be decoded.\n    \"\"\"\n    compressed_data = base64.b64decode(string)\n    original_data = lzma.decompress(compressed_data)\n    return original_data.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/skais_mapper/utils/primes/","title":"skais_mapper.utils.primes","text":""},{"location":"reference/skais_mapper/utils/primes/#skais_mapper.utils.primes","title":"skais_mapper.utils.primes","text":"<p>Functions for checking and computing prime numbers.</p> <p>Functions:</p> Name Description <code>is_prime</code> <p>An almost certain primality check.</p> <code>next_prime</code> <p>Next prime strictly larger than n.</p>"},{"location":"reference/skais_mapper/utils/primes/#skais_mapper.utils.primes.is_prime","title":"is_prime","text":"<pre><code>is_prime(n: int) -&gt; bool\n</code></pre> <p>An almost certain primality check.</p> Source code in <code>skais_mapper/utils/primes.py</code> <pre><code>def is_prime(n: int) -&gt; bool:\n    \"\"\"An almost certain primality check.\"\"\"\n    if n &lt; 212:\n        return n in SMALL_PRIMES\n\n    for p in SMALL_PRIMES:\n        if n % p == 0:\n            return False\n\n    # if n is a 32-bit integer (max. int is 2147483647), perform full trial division\n    if n &lt;= 2147483647:\n        i = 211\n        while i * i &lt; n:\n            for o in SIEVE_OFFSETS:\n                i += o\n                if n % i == 0:\n                    return False\n        return True\n\n    # Baillie-PSW\n    # this is technically a probabalistic test, but there are no known pseudoprimes\n    if not _is_sprp(n):\n        return False\n    a = 5\n    s = 2\n    while _legendre(a, n) != n - 1:\n        s = -s\n        a = s - a\n    return _is_lucas_prp(n, a)\n</code></pre>"},{"location":"reference/skais_mapper/utils/primes/#skais_mapper.utils.primes.next_prime","title":"next_prime","text":"<pre><code>next_prime(n: int) -&gt; int\n</code></pre> <p>Next prime strictly larger than n.</p> Source code in <code>skais_mapper/utils/primes.py</code> <pre><code>def next_prime(n: int) -&gt; int:\n    \"\"\"Next prime strictly larger than n.\"\"\"\n    if n &lt; 2:\n        return 2\n    # first odd larger than n\n    n = (n + 1) | 1\n    if n &lt; 212:\n        while True:\n            if n in SMALL_PRIMES:\n                return n\n            n += 2\n\n    # find our position in the sieve rotation via binary search\n    x = int(n % 210)\n    s = 0\n    e = 47\n    m = 24\n    while m != e:\n        if SIEVE_INDICES[m] &lt; x:\n            s = m\n            m = (s + e + 1) &gt;&gt; 1\n        else:\n            e = m\n            m = (s + e) &gt;&gt; 1\n\n    i = int(n + (SIEVE_INDICES[m] - x))\n    # adjust offsets\n    offs = SIEVE_OFFSETS[m:] + SIEVE_OFFSETS[:m]\n    while True:\n        for o in offs:\n            if is_prime(i):\n                return i\n            i += o\n</code></pre>"}]}